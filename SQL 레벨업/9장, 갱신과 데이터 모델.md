- 망치라는 도구만을 가지고 있는 사람에게는 모든 문제가 못으로 보인다.



## 27강_갱신은 효율적으로

보통 SELECT(SQL의 Query)만 관심을 가짐

갱신과 관련된 SQL 구문은 조금 느리다.



### 1. NULL 채우기

``` sql
CREATE TABLE OmitTbl
(keycol CHAR(8) NOT NULL,
seq INTEGER NOT NULL,
val INTEGER,
	CONSTRAINT pk_OmitTbl PRIMARY KEY (keycol, seq));
    
INSERT INTO OmitTbl VALUES
('A', 1, 50),
('A', 2, NULL),
('A', 3, NULL),
('A', 4, 70),
('A', 5, NULL),
('A', 6, NULL),
('B', 1, 10),
('B', 2, 20),
('B', 3, NULL),
('B', 4, 3),
('B', 5, NULL),
('B', 6, NULL);
```

- 빈 칸을 어떻게 채울까

반복계는 어렵다, 그러니 상간 서브쿼리를 사용해야..!

1. 같은 keycol 필드를 가짐
2. 현재 레코드보다 작은 seq 필드를 가짐
3. val 필드가 NULL이 아님

``` sql
UPDATE OmitTbl
SET val = (
    SELECT OT1.val
    FROM OmitTbl OT1
    WHERE OT1.keycol = OmitTbl.keycol
    AND OT1.seq = (
        SELECT MAX(seq)
        FROM OmitTbl OT2
        WHERE OT2.keycol = OmitTbl.keycol
        AND OT2.seq < OmitTbl.seq
        AND OT2.val IS NOT NULL
    )
)
WHERE val IS NULL;
```

Error Code: 1093. You can't specify target table 'OmitTbl' for update in FROM clause

- mysql에서 update문 subquery에서 OmitTbl 중첩으로 사용하면 안 돼서..

### 2. 반대로 NULL을 작성

반대로



## 27강. 레코드에서 필드로의 갱신

2개의 테이블 사용, 한쪽 테이블의 정보 편집 -> 다른 테이블로 복사

### 1. 필드를 하나씩 갱신

3개의 상관쿼리를 사용한 update문

느림

### 2. 다중 필드 할당

- 리스트를 사용하면 된다.



#### - 다중 필드 할당

(영어, 국어, 수학) 이라는 세 개의 필드를 리스트로 함

하나의 조작 단위로 만들 수 있음(mysql X)

#### - 스칼라 서브쿼리

서브쿼리 내부에 CASE식으로 과목별 점수 검색

각각에 MAX 함수를 적용



### 3. NOT NULL 제약이 걸려있는 경우

1. COALESCE를 활용한 서브쿼리, 그런데 매우 길다.
2. MERGE 구문 사용
   1. 마찬가지로 COALESCE 구문 사용하긴 한다..

사실 MERGE : Udate와 INSERT를 한 번에 시행하려고 고안된 기술



## 28강_필드에서 레코드로 변경

CASE 하나로 끝남.

완벽



## 29강_ 같은 테이블의 다른 레코드로 갱신

주식, 종가 -> 관련해서 새로운 테이블에 +, - 넣어야 하는 경우

1. 상관 서브쿼리
2. **윈도우 함수**
   - 빠르다

그런데 해당 문제는, 기존 테이블에 필드 하나를 추가해서 해결도 가능 한 부분

새로운 테이블을 만들어서 데이터를 INSERT 하는 방법

장

- UPDATE에 비해 성능이 훨씬 빠름, 고속 처리 기대
- 자기 참조 SQL을 허가하지 않는 DB에서도 사용 가능

단

- 같은 크기와 구조를 가진 데이터를 두 개 만들어야 함



만약 뷰를 만들어서 해결하면, 뷰에 접근할 때 마다 복잡한 연산이 수행되므로 접근하는 쿼리의 성능은 나빠짐(성능과 동기성에 trade-off)



## 30강_갱신이 초래하는 트레이드오프

주문(1) -> 주문 명세(n)

주문일(주문 테이블)과 배송 예정일(주문 명세 테이블)의 차이가 3일 이상이면 주문 배송이 늦어지고 있다 라고 알려주고 싶음

### 1. SQL 사용

- 조인해서 해결해야 함.(성능 bad)

### 2. 모델 갱신 사용

플래그라는 필드를 주문 명세 테이블에 만들면, 그냥 바로 구할 수 있겠네!

**망치라는 도구를 가진 사람에게는 모든 문제가 못으로 보인다**

- 냅다 SQL 쓰는 것은 안 좋은 방향

## 31강_모델 갱신의 주의점

트레이드 오프 3가지

### 1. 높아지는 갱신비용

새로운 필드 update

### 2. 갱신까지의 Time Rag 발생

1. 주문 등록(Orders 테이블)

   2. 주문 명세 등록 (OrderReceipts 테이블)

   3. 주문 명세 갱신 ( 여기 사이에 엄ㅊ). -> 여기서 Order의 주문 날짜가 바뀌면..?

4. 주문을 갱신 (안 맞아진다)

실시간성이 중요한 업무 -> 3,4를 한 번에 처리 -> 동일 트랜잭션? 

- 성능과 실시간성 사이에 심각한 트레이드오프



### 3. 모델 갱신비용 발생

프로젝트 막바지 -> 못 바꿈



## 32강_시야 협착: 관련 문제

주문번호마다 몇 개의 상품이 주문되었는지 알고 싶을 때

### 1. 다시 SQL을 사용한다면

결국 결합과 집약 필요(JOIN, GROUP BY)

윈도웋 마수도 사용

### 2. 다시 모델 갱신 사용

- 상품 수를 등록할 때 item_count 필드를 업데이트
- 그런데 한 번 등록한 주문을 나중에 변경한다면 상품 수도 함계 변경될 수 있따는 점

### 3. 초보자보다 중급자가 경계해야



## 33강_데이터 모델을 지배하는 자가 시스템을 지배한다

나쁜 데이터 구조 -> 복잡한 코딩으로 문제를 해결하는 경우가 많은데, 어렵다

**설계가 처음에 제일 중요!!**





