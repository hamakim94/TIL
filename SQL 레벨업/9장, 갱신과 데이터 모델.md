- 망치라는 도구만을 가지고 있는 사람에게는 모든 문제가 못으로 보인다.



## 27강_갱신은 효율적으로

보통 SELECT(SQL의 Query)만 관심을 가짐

갱신과 관련된 SQL 구문은 조금 느리다.



### 1. NULL 채우기

``` sql
CREATE TABLE OmitTbl
(keycol CHAR(8) NOT NULL,
seq INTEGER NOT NULL,
val INTEGER,
	CONSTRAINT pk_OmitTbl PRIMARY KEY (keycol, seq));
    
INSERT INTO OmitTbl VALUES
('A', 1, 50),
('A', 2, NULL),
('A', 3, NULL),
('A', 4, 70),
('A', 5, NULL),
('A', 6, NULL),
('B', 1, 10),
('B', 2, 20),
('B', 3, NULL),
('B', 4, 3),
('B', 5, NULL),
('B', 6, NULL);
```

- 빈 칸을 어떻게 채울까

반복계는 어렵다, 그러니 상간 서브쿼리를 사용해야..!

1. 같은 keycol 필드를 가짐
2. 현재 레코드보다 작은 seq 필드를 가짐
3. val 필드가 NULL이 아님

``` sql
UPDATE OmitTbl
SET val = (
    SELECT OT1.val
    FROM OmitTbl OT1
    WHERE OT1.keycol = OmitTbl.keycol
    AND OT1.seq = (
        SELECT MAX(seq)
        FROM OmitTbl OT2
        WHERE OT2.keycol = OmitTbl.keycol
        AND OT2.seq < OmitTbl.seq
        AND OT2.val IS NOT NULL
    )
)
WHERE val IS NULL;
```

Error Code: 1093. You can't specify target table 'OmitTbl' for update in FROM clause

- mysql에서 update문 subquery에서 OmitTbl 중첩으로 사용하면 안 돼서..

### 2. 반대로 NULL을 작성

반대로



## 27강. 레코드에서 필드로의 갱신

2개의 테이블 사용, 한쪽 테이블의 정보 편집 -> 다른 테이블로 복사

### 1. 필드를 하나씩 갱신

3개의 상관쿼리를 사용한 update문

느림

### 2. 다중 필드 할당

- 리스트를 사용하면 된다.



#### - 다중 필드 할당

(영어, 국어, 수학) 이라는 세 개의 필드를 리스트로 함

하나의 조작 단위로 만들 수 있음(mysql X)

#### - 스칼라 서브쿼리

서브쿼리 내부에 CASE식으로 과목별 점수 검색

각각에 MAX 함수를 적용



### 3. NOT NULL 제약이 걸려있는 경우

1. COALESCE를 활용한 서브쿼리, 그런데 매우 길다.
2. MERGE 구문 사용
   1. 마찬가지로 COALESCE 구문 사용하긴 한다..

사실 MERGE : Udate와 INSERT를 한 번에 시행하려고 고안된 기술



## 28강_필드에서 레코드로 변경

CASE 하나로 끝남.

완벽



