# 22/05/05

## 2장. 간단한 HTTP 프로토콜

### 2.1 HTTP는 클라이언트와 서버 간에 통신을 한다.

- TCP/IP  중 하나인 HTTP
- HTTP도 클라이언트와 서버간에 통신을 한다!
- 반드시 어느 한 쪽은 클라이언트, 반대는 서버!

---

### 2.2 request와 response를 교환하여 성립!

- HTTP는 클라이언트로부터 request가 송신! (클라이언트로부터 **무적권** 시작)
- 그 결과가 서버로부터 response로! ( 리퀘스트 없이는 안 돼 !)
- request 구조
  - 메소드(GET, POST 등)
  - URI(주소, /form/entry)
  - 프로토콜 버전(HTTP/1.1)
  - 리퀘스트 헤더 필드(뭐 이것저것 들어감)
  - 엔티티( 쿼리스트링같은데, 전달하는 정보 느낌)
- response 구조
  - HTTP 버전 , 리퀘스트의 처리 결과를 나타내는 상태 코드(200), 설명(OK)
  - 헤더 필드 : 리스폰스가 발생한 일시, Content-Length, Contemt-Type 등
  - <빈 줄>
  - 아래에 있는 부분 : body*리스폰스 본체 (\<html> ...)

---

### 2.3 HTTP는 상태를 유지하지 않는 프로토콜

- is the **STATELESS** protocol

  - HTTP 프로토콜 레벨에선, 이전에 보냈던 리퀘스트, 되돌려준 리스폰스 기억 못해(금붕어야!)

    => 많은 데이터를 매우 빠르고 확실하게 처리하는 **범위성(scalability)** 확보를 위함!

  - 근데, 로그인 같은거 어떻게 처리해? 상태 필요한데?  은행 거래를 위해 인증 했는데??

    - is the "Cookie"

---

### 2.4 리퀘스트 URI로 리소스를 식별

- HTTP는 URI(Uniform Resource Identifiers) => 인터넷 상의 리소스를 지정
  - 인터넷 상의 어떤 장소에 있는 리소스들 다 호출 가능!!!
- URI를 지정하는 여러 방법이 있단다(알고만 있자)

---

### 2.5 서버의 임무를 부여하는 HTTP 메소드

- GET : 리소스 획득
  - 리퀘스트 URI로 식별된 리소스(이미지, html, 데이터 등)을 가져올 수 있도록 요구
  - 지정된 리소스를 서버가 '해석'한 결과를 response에 돌려줌(이미진지, 텍스트읹, 뭔지 ..)
- POST : 엔티티 전송
  - 정보 전달! 기밀!  GET으로도 전송할 순 있는데, 자주 사용 안 한단다!
- PUT : 파일 전송
  -  인증 기능이 없어서 잘 안 씀, REST에서나 쓰지
  - 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한곳에 '보존'하도록 요구
- HEAD : 메시지 헤더 취득
  - GET과 같은 기능인데, 메시지 바디는 돌려주지 않아
  - URI 유효성 / 리소스 갱신 시간 확인 등 큰 목적 업승ㄹ 때
- DELETE : 파일 삭제
  -  인증 기능이 없어서 잘 안 씀, REST에서나 쓰지
  - request URI로 지정된 리소스의 삭제를 요구!
- OPTIONS : 내가 어떤 메또드(GET,POST,HEAD 등)을 쓸 수 있는지 알려주실?

- TRACE : 경로 조사(잘 안 써!)
  - 프록시 등을 중계하여 origin 서버에 접속 할 때 그 동작을 확인할떄. 쓴다네!
- CONNECT : 프록시에 터널링 요구
  - TCP 통신을 터널링 시키기 위해서 사용!
  - 무슨 뜻일까!
  - cf) 터널링?
    - 터널링은 인터넷을 사적(私的)이며 안전한 네트웍의 일부로서 사용하는 것으로서, 한 네트웍에서 다른 네트웍의 접속을 거쳐 데이터를 보낼 수 있도록 하는 기술

---

### 2.6 메소드를 사용해서 지시를 내리다

- 저기 위에있는 메또드들 + 리퀘스트 URI 로 보낸다!

---

### 2.7 지속 연결로 접속량을 절약

- HTTP 초기 버전 : HTTP로 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 해야했음
- 이미지 10개 필요 -> 10번 TCP 연결 해서 하나씩 가져와야해.. 무리 death!

#### 2.7.1 지속 연결

- Persistent Connections => TCP 연결 문제 해결
  - 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 끝내지 않아!!
- TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여줌 -> 서버에 대한 부하 경감

#### 2.7.2 파이프라인화

- 지속 연결 + HTTP pipelining
  - 리퀘스트 송신 후 리스판스 기다리는게 아니라, 바로 다음 리퀘스트 보낼 수 있음
  - 리퀘스트를 병행해서 보내는 것이 가능 -> 일일이 리스폰스 기다릴 필요 X
    - 비동기 설명할 때랑 느낌 비슷하당!

개별 연결 < 지속 연결 < 파이프라인 순으로  빠르당!!

---

### 2.8 쿠키를 사용한 상태 관리

- HTTP : stateless protocol

  - 상태를 저장하지 않아, 로그인, 인증 등을 어떻게 유지해? 

- 쿠키는 request와 response에 쿠키 정보를 추가!!

- 로그인 -> 서버(Set-Cookie 헤더 필드) => 쿠키를 **클라이언트**에 보존

  - 다음부턴 쿠키 가진 채로 요청이 되겠네!?!??! 오 이녀석 박문철이 된 느낌!?

  

---

