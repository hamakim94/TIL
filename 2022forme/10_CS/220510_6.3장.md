# 22/05/10

## 6.3 HTTP/1.1, 일반 헤더 필드

### 6.3.0. 일반 헤더 필드

- 그래서 이게 뭔데?
  - **리퀘스트 메시지**와 **리스폰스 메시지** **양쪽에서 사용**되는 **헤더**

---

### 6.3.1 Cache-Control

#### 사용법

- Cache-Control 헤더는 **디렉티브**로 불리는 명령을 사용하여 캐싱 동작을 지정
- 사용 가능한 디렉티브를 리퀘스트/리스판스 별로 나눈게 114page 표 6-5, 6-6
- 디렉티브:
  - Cache-Control 내부에 또 하나의 키라고 생각중..(민균's thinking)

---

#### 6.3.1.1 캐시가 가능한지 여부를 나타내는 디렉티브

##### 1) public 디렉티브 Cache-Control : public

- public : 다른 유저에게도 돌려 줄 수 있는 캐시를 해도 좋다!

##### 2) private 디렉티브 Cache-Control : private

- 리스폰스는 특정 유저만을 대상으로 캐시중!
- 다른 유저로부터 같은 리퀘스트 -> 그 캐시 반환 안 해 !

##### 3) no-cache 디렉티브 Cache-Control : no-cache

- 캐시로부터 오래된 리소스가 반환되는 것을 막기 위함!
- 캐시된 리스폰스가 있다고 하더라도 클라이언트가 받질 않아
  - **중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송해!**
- cf) no-cache=Location(특정 헤더 필드 명)
  - 지정된 헤더 필드 이외에는 캐시 가능~(리스폰스만 이용 가능)

---

#### 6.3.1.2 캐시로 보존 가능한 것을 제어하는 디렉티브

##### 1) no-store 디렉티브      Cache-Control : no-store

- is the **기밀정보** 
- 절 대 따 로 보 관 (저장) 하 지 마 

---

#### 6.3.1.3 캐시 기한 디렉티브

##### 1) s-maxage 디렉티브     Cache-Control : s-maxage=604800 (단위 : 초)

- max-age랑 동일하지만, **여러 유저**가 이용할 수 있는 **공유 캐시 서버**에만 적용
- 같은 유저에 반복해서 리스폰스를 반환하는 캐시 서버는 무효(우리가 하는 배포 안 할 쪼꼬미 프로젝트들은 X)
  - 그냥 이렇게 생각하기로 했슴돠.

##### 2) max-age 디렉티브     Cache-Control : max-age=604800 (단위 : 초)

- 클라이언트의 경우
  - 지정값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있음(오래 있었으면 바꿔줘)
  - 0으로 지정? -> 캐시 서버는 리퀘스트를 맨날 오리진 서버에 넘겨줘야함
- 리스폰스의 경우
  - 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 두는 최대 시간

##### 3) min-fresh 디렉티브     Cache-Control: min-fresh=60 (단위 : 초)

- 캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요구
  - 지정한 시간보다 유효 기간이 긴 것만 리스폰스로 보내줘! 자주 바뀌는거 싫어!(10초로 선정시)

---

#### 6.3.1.4 캐시 검증 디렉티브

##### 1) max-stale 디렉티브   Cache-Control: max-stale=3600 (단위 : 초)

- 캐시된 리소스의 유효기간이 끝나도, 지정한 시간 이내라면 받아들일 수 있음!

##### 2) only-if-cached 디렉티브     Cache-Control: only-if-cached

- 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우에만 리스폰스 반환
- 캐시 서버에서, 리스폰스의 리로드나 유효성을 재확인 X
- 캐시 서버가 로컬 캐시로부터 응답 X -> "504 Gateway Timeout"

##### 3) must-revalidate 디렉티브 Cache-Control: must-revalidate

- 리스폰스의 캐시가 현재도 유효한지 오리진 서버에 조회를 요구 (max-stale 무시할 수 있는 강력한 녀석)

##### 4) proxy-revalidate 디렉티브     Cache-Control: proxy-revalidate

- **모든** 캐시 서버에 대해서 리퀘스트로 해당 리스폰스를 반환할 떄는 반드시 유효성을 재확인해!

##### 5) no-transform 디렉티브     Cache-Control: no-transform

- 리퀘스트, 리스폰스 둘다, 엔티티 바디의 미디어 타입 변경 하지 마!
- 압축 하지 마!!!

#### 6.3.1.5 Cache-Control 확장

##### 1) cache-extension token     Cache-Control: private, community = "UCI"

- Cache-Control 헤더 필드에는 없지만, extension token에 있는 경우
- 커뮤니티 이해 못 하면 무시

---

### 6.3.2 Connection

#### 두 가지 역할

##### 1) 프록시에 더 이상 전송하지 않는 헤더 필드를 지정

- **Connection : 더 이상 전송하지 않는 헤더 필드 명**
  - Connection 헤더 필드를 사용해서 프록시 서버엔 전송하지 않는 헤더 필드(hop-by-hop 헤더) 설정 가능

##### 2) 지속적 접속 관리

- **Connection :Close**
  - HTTP : 지속적 접속 DEFAULT => 리퀘스트 송신했던 클라이언트는 접속 유지, 추가 리퀘스트 있니??
  - 서버 측에서 명시적으로 접속을 끊고 싶은 경우는 Connection 필드에 Close !
- **Connection : Keep-Alive**
  - HTTP 1.1 이전엔 지속적 접속이 Default가 아니였음
  - 오래된 버전이면 Connection header field에 Keep-Alive 보내!

---

### 6.3.3 Date

- Date 헤더 필드는 HTTP 메시지를 생성한 날짜

  - Date : Tue, 03 Jul 2012 04:40:59 GMT                                  (곤맛탱)

  - 대충 다른 포맷도 있다~

---

### 6.3.4 Pragma

- **Pragma : no-cache**
  - 클라이언트의 리퀘스트에서만 사용가능
  - 캐시된 리소스의 리스폰스를 원하지 않음을, **모든 중간 서버에 알리기 위함**
    - 모든 중간 서버가 HTTP/1.1 사용하면 Cache-Control: no-cache 사용하면 됨
    - 중간에 다른 버전 있을까봐, 둘 다 보내는 경우도 있다

---

### 6.3.5 Trailer

- HTTP/1.1 청크 전송 인코딩을 사용하고 있는 경우 사용 가능
- 메시지 바디 뒤에 기술되어 있는 헤더 필드를 미리 전달 가능
  - 메시지 바디 중 중요한 정보 미리 전달!!!

---

### 6.3.6 Transfer-Encoding

- HTTP/1.1 : only Chunked

---

### 6.3.7 Upgrade

- HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용 되는 경우
  - Upgrade 헤더 필드에 의해서 업그레이드 되는 대상은 클라이언트와 인접한 서버 사이뿐이기때문에
  - 서버와 클라이언트 양쪽 모두 Connection: Upgrade로 저장!!

---

### 6.3.8 Via 교환 

- 서버 간에 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서!
- TCP/IP 4단계에서, 캡슐화되는것 처럼 via도 쌓인다!

---

### 6.3.9 Warning 

- 리스폰스에 관한 추가 정보를 전달
- **캐시에 관한 문제의 경고를 유저에 전달**
  - 110, 111, 112, 113, 199, 214, 299 등이 해당