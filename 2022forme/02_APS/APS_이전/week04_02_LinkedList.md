# 22/02/23

## 순차리스트

#### 리스트

- **순서를 가진** 데이터의 집합을 가리키고, 추상 자료형(abstract data type)
- 동일한 데이터를 가지고 있어도 상관 없다



- 구현 방법에 따라 크게 두 가지
  - 순차 리스트 : 배열을 기반으로 구현된 리스트
  - 연결 리스트 : 메모리의 동적 할당을 기반으로 구현된 리스트

---

- 리스트 메또드
  - addtoFirst() : 리스트 맨 앞쪽에 원소를 추가하는 연산
  - addtoLast() : 리스트 뒤쪽에 원소 추가
  - add() : 리스트의 **특정 위치에 원소를 추가**
  - delete() : 리스트 **특정 위치에 있는 원소 삭제**
  - get() : 리스트 특정 위치에 있는 원소 리턴

---

#### 구현

- 1차원 배열에 항목들을 순서대로 저장
- 데이터의 종류와 구조에 따라 구조화된 자료구조(class)를 만들어 배열로 만들 수도 있다.

#### 데이터 접근

- 배열의 인덱스를 이용해 원하는 위치의 데이터에 접근할 숭 있다(접근 Good.)

#### 삽입 연산

- 삽입 위치와 그 다음의 항목들을 1칸씩 이동해야 한다,(뒤로밀착!0)
  - 뒤로밀착 : 뒤에 있는 원소부터 이동해야해(앞에 있는거 먼저 하면 뒤에 있는게 사라져버려.)

#### 삭제 연산

- 삽입 위치를 제거하고, 뒤에 항목들을 앞으로 당겨줘야 한다.
  - 앞으로 밀착 : 앞에 있는 원소부터 땡겨와야 한다 ( 어디가 마지막인지 알고 있어야 함)

---

#### 문제점

- 단순 배열 이용해 순차리스트를 구현하면, 자료의 삽입/삭제 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요
- 원소의 개수가 많고, 삽입/삭제 연산이 많이 일어나면 작업에 소요되는 시간이 크게 증가
- 배열의 크기가 정해져있으면, 실제로 사용될 메모리보다 크게 할당해 메모리 낭비, 반대로 할당된 메모리보다 많은 자료를 사용해 새롭게 배열을 만들어 작업을 해야하는경우 발생.



## 연결리스트

#### 특성

- 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 주소를 연결에 하나의 전체적인 자료구조를 이룬다
- 링크르 통해 원소에 접근하므로, 순차리스트에서처럼 물리적인 순서를 맞추기 위한 작업이 필요 X
- 자료구조 크기 동적으로 조정 가능, 메모리의 효율적인 사용 가능

---

#### 노드

- 연결리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
- 구성 요소
  - 데이터 필드
    - 원소의 값을 저장하는 자료구조
    - 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용
  - 링크 필드
    - 다음 노드의 주소를 저장하는 자료구조

---

#### 헤드

- 리스트의 처음 노드를 가리키는 레퍼런스

## 단순 연결 리스트

#### 연결 구조

- 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조
- 헤드가 가자 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다
- 최종적으로는 NULL을 가리키는 노드가 리스트의 가장 마지막 노드이다.(이게 마지막이군!!)

---

#### 삽입? 

1. 노드 삽입(데이터 할당)
2. 링크필드 그 다음 노드의 주소
3. 이전 필드의 링크가 새 노드의 주소

- 이 순서를 유지해야지, 아니면 G.C가 먹을 수 도 있어(연결이 안 돼있으면!)

---

#### 삭제

- 이전 노드의 링크 주소를, 다음 노드에 연결되면 됩니다.



## 이중 연결 리스트 - 마음의 숙제

#### 특성

- 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
- 두 개의 링크 필드와 한 개의 데이터 필드
- 



## 연결 스택

- 리스트를 활용해서 스택 구현 가능!
- 스택의 원소 : 리스트의 노드
  - 스택 내의 순서는 리스틀의 링크르 통해 연결됨
    - Push : 리스트의 마지막 노드에 삽입
    - Pop : 리스트의 마지막 노드 반환 / 삭제
- 변수 top
  - 리스트의 마지막 노드를 가리키는 변수
  - 초기값 : null



==  고민을 해볼 볼 필요는 있다(그림) == 

## 연결 큐

- 큐의 원소 : 단순 연결 리스트의 노드
- 큐의 원소 순서 : 노드의 연결 순서, 링크로 연결
- front : 첫 번째 노드를 가리키는 링크
- rear : 마지막 노드를 가리키는 링크

## 우선순위 큐

- 배열을 이용하여 우선순위 큐 구현
  - 배열을 사용하요 자료 저장
  - 원소를 삽입하는 과정에서 우선순위 비교, 적절한 위치에 삽입
  - 가장 앞에 최고 우선순위의 원소가 위치
- 문제점
  - 배열을 사용, 삽입/삭제 !! 메모리 낭비 커

---

- 리스트 사용
  - 연결 리스트 자료 저장
  - 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교해 적절한 위치에 노드를 삽입
  - 리스트의 가장 앞쪽에 최고 우선순위 위치
- 장점(배열대비)
  - 삽입/삭제 연산 이후 원소의 재배치 필요 없음
  - 메모리의 효율적인 활용

## 요세푸스 문제

큐 이용

## 삽입 정렬

- 도서관 사서가 책을 정렬 할 때, 일반적으로 활용되는 방식
- 자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교, 자신의 위치를 찾아냄으로써 정렬을 완성한다.

#### 과정

- 부분집합 S : 정렬된 앞부분 원소들
- 부분집합 U : 아직 정렬되지 않은 나머지 원소들
- 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬돼있는 부분집합 S에 마지막에 넣어저



O(n)