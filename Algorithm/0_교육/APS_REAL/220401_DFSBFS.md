# 22/04/01

- 트리(그래프, 2차원 배열) 순회(탐색)는 모든 자료(노드, 정점)를 빠짐 없이 탐색한느 것.
- 두 가지 방법이 있다.



## 1. 깊이 우선 탐색(Depth First Search DFS)

#### 빌리지 손가락

### 개념

- DFS는 깊이 우선 탐색

- 루트 노드(시작 정점, 출발 위치)에서 출발하여 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 노드(정점)로 되돌아와서 다른 방향의 노드(정점)으로 탐색을 계속 반복하여 결국 모든 노드(정점)을 방문하는 순회 방법



- 가장 마지막에 만났던 갈림길의 노드(정점)로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로, 후입선출(LIFO : Last in First-Out) 자료구조인 스택 사용
  - 마지막에 저장해 놓은 노드로 돌아가기 위해 스택!

- 재귀함수는 시스템 스택을 이용하므로 이를 이용하여 간단하게 구현할 수도 있음

---

- 탐색 방법
  - 루트 노드 stack push
  - stack 공백상태가 될 떄 까지 반복
    - stack에서 노드(curr) pop
    - curr의 모든 자식 push

~~~pseudocode
DFS(v) {
	stack.push(v)
	while(not stack.isEmpty){
		curr = stack.pop
		for w in (curr의 모든 자식)
			stack.push(w)
	}
}
~~~

---

- 탐색 방법(재귀)
  - 현재 노드(v) 방문
  - (v)의 자식 노드(w)를 차례로 재귀 호출

~~~ pseudocode
DFS(V){
	v 방문
	for w ini (v의 모든 자식){}
		DFS(w);
		}
}
~~~

---

- 그래프 탐색!
  - 갔던곳 왔다갔다 해 ㅠㅠ
  - 방 문 처 리 ! 

~~~ pseudocode
// G : 그래프, visited : 방문 배열
DFS(v){
	visited[v] <- TRUE // v 방문 설정
	
	FOR each all w in adjacencty(G, v){     (인접행렬, 인접리스트ㅁㅇ)
		if visited[w] != TRUE
			DFS(w)
	}
}
~~~

- 2차원 배열에서도 가능!!



## 2. 너비 우선 탐색(Breadth First Search, BFS)

#### 초음파, 와이파이 모양

### 개념

- BFS는 너비 우선 탐색
- 너비우선탐색은 탐색 루트노드(시작 정점, 출발위치)의 자식 노드(인접한 정점)들을 먼저 모두 차례로 방문한 ㅇ후에 방문했던 자식 노드들(인접한 정점)을 시작점으로 하여 다시 해당 노드의 자식 노드(인접한 정점)들을 차례로 방문하는 방식



- 자식 노드(인접한 정점)들에 대해 탐색을 한 후, 차례로 다시 너비 우선 탐색을 진행해야 하므로, 선입선출(FIFO )형태의 자료구조인 큐를 활용

- 너비 우선 탐색은 인접한 노드들부터 차례대로 방문을 하므로 시작 정점과 끝 정점이 주어졌을 떄 

---

### 방법

1) 루트 노드 Queue에 삽입
2) Queue가 공백이 될때 까지 반복ㄷ 수행
   1) Queue에서 원소 꺼내기
   2) 해당 원소 방문
   3) curr의 자식 노드, Queue의 삽입.

---

## 3. 최단거리? => BFS!!

1. 2차원 배열을 만들어 직접 길이를 저장한다.
2. 큐에 넣을 때 같이 넣어 저장한다(클래스 멤버변수로 함께 저장)
3. 길이를 저장하는 변수를 생성하여 이를 활용한다(Queue size를 묶어 같은 레벨끼리 처리)





