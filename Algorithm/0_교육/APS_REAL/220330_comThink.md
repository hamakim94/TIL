# 220330

## 공통조상문제

- 왼쪽자식, 오른쪽자식, 각 자식의 부모를 넣는 배열을 따로 만드는 방법이 있다

  - 그렇게 해서, 하나를 넣고 부모로 가서 -1넣어주고

  - 다른 하나는 -1 나오면 그만!

- 그다음에 전위, 후위 순회든 아무거나 해서, 들어갈때마다 +1 해주면 끝나는 문제



## 컴퓨터 띵킹

### 배타적 논리합 XOR

- 같은 거면 F, 다르면 P (하나만 참!)

| p    | q    | p XOR Q |
| ---- | ---- | ------- |
| T    | T    | F       |
| F    | T    | T       |
| T    | F    | T       |
| F    | F    | F       |

## 수와 표현

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k - 1 까지 표현 가능
- 사실 꼭 저 범위는 아님, 약속하는 방식에 따라 다르지만, 어떤 경우든 최대 2^k 까지의 값을 표현 가능
- 10진수로 k자리를 쓰면 0부터 10^k-1 까지 표현이 가능한 것과 완전히 동일



#### 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요?

- 2^k - 1 >= n 이 성립해야함
- 같은 의미로, k >= log(n+1) : 약 로그 n비트가 필요



- log n은

  - 2의 몇 승이 n이 되느냐
  - n을 표현하는데 몇 비트가 필요하냐
  - 1로 시작해서 계속 두배를 할 때 몇 번 하면 n이 되니의 답
  - n을 2로 계속 나눌 때 몇번 나누면 거의 1이 되느냐 의 답

- x = logn은

  - x가 값이 더 작고, n이 커질수록 엄청나게 달라진다
  - 100자리로 표한할 수 있는 10진수 값은 읽을수도 없을 정도로 큰 값
  - 컴퓨터 분야에서 로그의 밑은 항상 2 

- 문제

  - 문제 1. 2진수 표현에서 로그n 비트로 편할 수 있는 숫자 가지 수는?

  - 그럼 n비트로 표현할 수 있는 가지수? 2^n개

- 문제 2

  - 스무고개가 이상적으로 진행된다고 할 때, 답변

## 집합과 조합론

- 설명
  - 두 집합 A, B에 대해 A가 B의 부분 집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 겉과 같음
  - 예를 들어 모든 4의 배수는 2의 배수ㄹ라는 것을 증명하려면  4k  2(2k) 임을 보이면 됨
  - 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분 집합이고 B가 A의 부분집합임을 증명하면 된다



- 귀류법
  - 거짓이라 가정하고 모순 끌어내기





## 기초 수식

- 약간의 설명
  - 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존자한다
  - 풀이법을 익혀 두어여 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘의 시간이 얼마나 걸릴 지 예측할 수 있다.
- Big O : .점근적 상향(큰 경우를 대충 생각)
  - T(n) = T(n-1) + log(n), T(0) = 1
  - nlogn
  - 쭉 넣어봐서
  - 맨 마지막에 n에 들어가있는걸 1이 되는 k를 구하고
  - 더해준다(그리고 big O 적용)

## 재귀

- 약간의 설명
  - 재귀란 자기 자신을 호출한느 함수, 그럼 끝날 수 있나?
  - 함수는 입력이 이쓰며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음
  - 하지만 다른 입력으로 호출하면 끝날 수 있음
- 재귀
  - base
  - recursive



#### 함수란

- 어떤 문제를 해결하는 방법을 코딩한 것
- 어떤 문제의 단 한 케이스만을 해결하는 것이 아님
- 제대로 코딩 됐으면 해결하는 문제의 **모든 케이스들**을 해결해야 함
- 수학적 귀납법 사용 가능
  - n이 0일때 풀수 있음 ( base )
  - n-1에서 문제 풀수 있으면 n에서도 문제 풀 수 있음 ( recursive)
- 위 두가지가 사실이면 모든 가능한 n에 대해 풀 수 있음



- 다르게 생각 법

  - 어떤 문제를 만났을때 부분 문제를 만났는데, 원래 하려던 입력 케이스와 동일한 문제에 속하지만 크기가 더 작은 입력 케이스를 해결하는 것이 그 부분 무제
  - 즉 부분 문제가 동일한 경우! => 재귀

- 피보나치

  - T(n)= T(n-1) + T(n-2) + 1

    ​      < 2*T(n-1) + 1











