# 220404 START & 완전탐색!

## 복잡도 분석

### 알고리즘의 효율

- 공간적 효울성과 시간적 효율성
  - 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다
  - 시간적 횽ㄹ성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다
  - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 된다
  - 복잡도가 높을수록 효율성은 저하된다.
- 시간적 복잡도 분석
  - 하드웨어 환경에 따라 처리시간이 달라진다.
    - 부동소수 처리 프로세서 존재 유무, 나눗셈 가속기능 유무
    - 입출력 장비의 성능, 공유 여부
  - 소프트웨어 환경에 따라 처리시간이 달라진다.
    - 프로글매 언어의 종류
    - 운영체제, 컴파일러 종류
  - 이러한 차이로 인해 분석이 어렵다.

---

- 복잡도의 점근적 표기
  - 시간 또는 공간 복잡도는 입력 크기에 대한 함수로 표기, 이 함수는 주로 여러 개의 항을 가지는 다항식
  - 이를 단순한 함수를 표현하기 위해 점근적 표기를 사용
  - 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법

---

### BIG-Oh

- O-표기는 복잡도의 **점근적 상한**을 나타낸다
- f(n) 의 단순화된 표현은 n^2이다
- 단순화된 함수 n^2에 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 상한이 된다.
- **최악의 경우 이정도는 걸려!!**

### BIG Omega

- **최소한 이만한 시간은 걸린다.**
- 점근적 하한!

### THETA 표기

- O표기와 오메가 표기가 같을 때

---

### 자주 사용하는 O-표기

O(1) : 상수 시간 (constant time)

O(logn) : 로그 시간

O(n) : 선형 시간

O(nlogn) 로그 선형 시간

O(n^2) 제곱 시간

O(n^3)세제곱 시간

O(2^n)지수 시간

---

### 왜 효율적인 알고리즘이 필요?

- 10억개의 숫자를 정렬하는데 PC에서 O(n2)알고리즘은 300여년,  O(nlogn) : 5분만에
- 효율적인 알고리즘은 슈퍼컴퓨터보다 큰 가치를 지님
- 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적



## 진수

- 2진수, 8진수, 10진수, 16진수
- 10진수 -> 타 진수로 변환
  - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
  - 8,16진수 , 2진수 3개, 4개씩 읽기
- 타진수 -> 10진수로 변환
  - 열심히 곱해

---

### 컴퓨터에서의 음의 정수 표현 방법

- 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환

- 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다(요즘 방법) , ~연산

## 실수

### 실수의 표현

- 소수점 이하의 4자리를 10진수를 나타내기.

2진수 0.0001 = 0.0625(2^-4)

2진수 0.0010 : 0.125 (2^-3)   ... 그런데 0.1을 표현할 방법이 없네?

- 컴퓨터는 실수를 어떻게?
  - 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다
    - 부동 : 동동 떠다녀서 고정!
  - 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다
    - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현.

- 1001.0011 -> 1.0010011 * 2^3

### 실수를 저장하기 위한 형식

- 단정도 실수(32비트)
- 배정도 실수(64비트)

- 가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것(0010011)
- 지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것 ( 2^3)



- 단정도 실수의 가수부 만들기

  - 정수부의 첫 번째 자리가 1이 되도록 오른쪽으로 시프트
  - 소수점 이하를 23비트로 만든다
  - 소수점 이하만을 가수 부분에 저장
  - 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소

- 단정도 실수의 지수 부분을 만드는 방법

  - 지수 부에는 8비트가 배정(256개 상태를 나타낼 수 있음)
  - 숫자로는 0-255, 음수 값을 나타내야 할 수있어야 하므로 excess 표현법 사용
    - 익세스 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현

- | 실제지수 | 2진수    | 10진수값 |
  | -------- | -------- | -------- |
  | 128      | 11111111 | 255      |
  | 0        | 01111111 | 127      |
  | -127     | 00000000 | 0        |

- **컴퓨터는 실수를 근사적으로 표현한다**

  - 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장되는대, 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.

- 실수 자료형의 유효 자릿수를 알아두자

  - 32비트 실수형 유효자릿수(십진수) -> 6
  - 64비트 실수형 유효자릿수(십진수)  -> 15



## 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합이라고 부른다.
- 직접 계산 안 함, 파스칼의 삼각형을 2차원 배열로 직접 만들거나, 재귀로..

- nCr = n-1Cr-1 + n-1Cr : 재귀적 표현

| n개 중에, 마지막 하나 안 뽑았어 | n개중에, 마지막 하나는 무조건 뽑아 |
| ------------------------------- | ---------------------------------- |
| n-1Cr                           | n-1Cr-1                            |

- nC0 : 1개도 안 뽑는 경우는 오직 1개!
- nCn : 1
- 생각해보니, nCn/2 가 최대값, 따라서 문제를 보고 숫자가 너무 크면 팩토리얼 안 되겠네..

### 재귀 호출을 이용한 조합 생성 알고리즘

~~~pseudocode
data[] : n개의 원소를 가지고 이쓴 배열
idx : data 배열의 인덱스
sel[] : r개의 크기의 배열, 조합이 임시 저장될 배열
sidx : sel 배열의 인덱스, 


comb(idx, sidx)
	IF sidx == r : print_array()
	ELSE IF idx >= n : RETURN
	ELSE
		sel[sidx] <- data[idx]
		comb(idx+1, sidx+1) (뽑고)
		comb(idx+1, sidx) (안뽑고)
~~~

### 반복문을 이용한 조합 생성 알고리즘

~~~ pseudocode
// {1,2,3,4} 중 원소 3개를 뽑장
FOR i from 1 to 2{
	FOR j from i+1 to 3{
		FOR k from j+1 to 4{
			print i, j, k;
		}
	}
}
~~~

근데, 일반적으로 r개의 원소를 뽑을 때 r개의 반복문이 필요하다..

근데 몇 개를 뽑는지 모르는 경우 때문에 재귀로 만들 줄 알아야 한다!

~~~pseudocode
data[] : n개의 원소를 가지고 이쓴 배열
idx : data 배열의 인덱스
sel[] : r개의 크기의 배열, 조합이 임시 저장될 배열
sidx : sel 배열의 인덱스, 

comb(idx, sidx)
	IF sidx == r : print_array()
	ELLSE
		FOR i from idx to N-R+sidx
			sel[sidx] <- data[i]
			comb(i+1, sidx + 1)
~~~

---

## 부분 집합

### 비트 연산자

| 연산자 | 연산자기능                                      |
| ------ | ----------------------------------------------- |
| &      | 비트 단위로 AND                                 |
| \|     | 비트 단위로 OR                                  |
| ^      | 비트 단위로 XOR(같으면 0 다르면 1)              |
| ~      | 단항 연산자, 피연산자의 모든 비트를 반전시킨다. |
| <<     | 피연산자의 비트 열을 왼족으로 이동시킨다.       |
| >>     | 피연산자의 비트 열을 오른쪽으로 이동시킨다.     |

### 부분집합이란

- 집합에 포함된 원소들을 선택하는 것이다
- 다수의 중요 알고리즘들이 원소의 그룹에서 최적의 부분집합을 찾는 것이다.
  - 예 > 배낭 집싸기(knapsack)
- N개의 원소를 포함한 집합
  - 자기 자신과 공집합 포함한 모든 부분집하의 개수는 2^n개
  - 원소의 수가 증가하면 부분집합의 수는 지수적으로 증가한다.

---

### 비트마스킹 이용해서 부분집합 구하기

~~~java
// N : 원소의 개수, 4개인 경우
// 부분집합의 수 만큼 반복 돌리기

for(int i=0; i< (1<<N); i++){
    for(int j=0; j<N; j++){
        if((i&(i<<j)) > 0 ){
            처리
        }
    }
}
~~~

---

### 재귀 호출을 이용하여 부분집합 구하기

~~~java
// sel[] : 해당 원소 포함 여부 저장
//  n: 원소의 개수, k : 현재 depth

static void powerset(int n, int k){
    if(n == k){
        print(sel);
        return
    }
    sel[k] = false;
    powerset(n, k+1);
    sel[k] = true;
    powerset(n, k+1);
    
}
~~~

## 순열

### 정의

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개중 r개를 택하는 순열은 아래와 같이 표현한다. nPr
  - nPr = n * (n-1) * (n-2 ) * ... * (n-r+1) == n! / (n-r)!
- nPn 은 n!이라고 표기하며, Factorial이라 부른다.
  - n! = n * (n-1) * (n-2) * ... * 1



- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다.
  - ex ) TSP
- n개의 요소들에 대해서 n!개의 순열들이 존재한다
  - 12! = 479,001,600
  - n>12인 경우, 시간 복잡도가 폭팔적으로 증가한다.

---

### 단순하게 : list1시간에 했음.

---

### 방법들

- 사전적 순서
  - {1,2,3}, n=3 인 경우 다음과 같이 생성된다
  - [123] [132] [213] [231] [312] [321]
- 최소 반경을 통한 방법(Minimum-exchange requirement)
  - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들을 교환해서 만든다
  - 1950년대 교회의 종소리와 비슷
  - Johnson-Trotter 알고리즘(어려움)

~~~pseudocode
// arr[] : 데이터가 저장된 배열
// swap(i,j) : arr[i] arr[j] 교환
// n : 원소의 개수, k : 현재까지 교환된 원소의 개수
perm(n, k)
	IF k==n
		print array//원하는 작업 수행
	ELSE
    	FOR i in k -> n-1
    		swap(k,i);
    		perm(n,k+1);
    		swap(k,i);
	
~~~

---

### 방문 체크를 통한 순열 생성

~~~pseudocode
nums : 데이터
result : 결과 저장 배열
check : 해당 원소 사용했는지 체크하기 위한 배열

permutation(idx){
	if idx == N
		(순열완료)
		return
	for i from 0 to N-1
    	if check[i] { continue }
    	result[idx] = nums[i]
    	check[i] = true
    	permutaion(idx + 1)
		check[i] = false
}
~~~

---

### 비트마스킹을 통한 순열 생성

~~~ pseudocode
nums : 데이터
result : 결과 저장 배열
visited : 해당 원소 사용했는지 체크

permutation(idx, visited){
	if idx == N
		(순열생성완료)
		return
	for i from 0 to N-1
		if visited & (1<<i) != 0 { continue}
		sel[idx] = nums[i]
		permutation(idx + 1, visited | 1 << i)
}
~~~

