### 

# 섹션 1. 스프링의 핵심 원리

핵심 : 객체 지향

## 0_탄생 이유

EJB가 표준

이론은 매우 좋음, 너무 어렵고 느림

EJB 엔티티 빈 -> JPA, 하이버네이트



2002년 로드 존슨 책 출간(J2EE Design and Development)

2009년 스프링 프레임워크 3.0 출시 이후 자바 코드로 설정 가능(XML 너무 어려워)

---

## 1. 스프링이란?

필수 : **스프링 프레임워크**, 부트

선택 : 데이터, 세션, 시큐리티, Rest Docs, batch, cloud .. etc

spring.io 들어와서 오버뷰를 보면 이것저것 나온다



cf) orm : Object-Relational Mapping

- 객체와 관계형 db랑 연결



스프링 단어

- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트 등 생태계



### 왜?(핵심 개념, 아무리 복잡한 기술도 단순하게 설명 가능함)

- 이 기술을 왜 만들었는가
- 이 기술의 핵심 컨셉은?

**좋은 객체 지향 애플리에키션을 개발할 수 있게 도와주는 프레임워크**

순수한 객체 지향으로 돌아가자( POJO!!!! , 즉 EJB 기반으로 하면 EJB 형식으로만 코드를 짜야 하니까..!! )

---

## 2. 좋은 객체 지향 프로그래밍이란

객체지향 특징

- 추상화
- 캡슐화
- 상속
- **다형성**



- 객체 지향 프로그래밍은 명령어 목록이 아니라, 여러개의 독립된 단위, 즉 **"객체"**들의 모임으로 파악하고자 하는 것. 각각의 객체는 **메세지**를 주고받고, 데이터를 처리할 수 있다(협력)

- **유연하고 변경이 용이**

  - 레고 블럭 조립

  - 키보드, 마우스 갈아 끼우기,

  - 컴퓨터 부품 갈아 끼우듯이 등등

    - **다형성!!**

      

다형성의 실세계 비유

- **역할**과 **구현**으로 세상을 구분(인터페이스, 객체)



### 운전자 역할, 자동차 역할

자동차가 바뀌어도 운전자에게 영향을 안 끼침..!!!!! 

- 왜 자동차 역할을 만들었을 까?
  - 운전자를 위해서
  - 운전자는 어떻게 굴러가는지 내부 구조를 모른다
  - 그러나 자동차 역할만 하고 있으면 운전 가능!

클라이언트한테 영향을 주지 않고 새로운 기능 개발 가능!

**새로운 자동차가 나와도 새로운걸 배울 필요가 없다**



### 로미오와 줄리엣 공연

로미오 역할, 줄리엣 역할 -> 이 역할을 연기하는 배우들은 많다, 즉 배우들은 대체가 가능해야해!



### 역할과 구현을 분리하면..

- 세상이 단순, 유연, 변경 편리
- 클라이언트는 역할(인터페이스)만 알면 돼
- 클라이언트는 내부 구조 몰라도 돼
- 클라이언트는 구현 대상의 내부 구조가 변경돼도 영향 X
- 클라이언트는 대상 자체를 변경해도 영향 X

역할은 인터페이스, 구현은 인터페이스를 구현한 클래스, 구현 객체!

**결국, 역할이 더 중요하다**



###  객체의 협력이라는 관계

- 혼자 있는 객체는 없다.
- 클라는 **요청**, 서버는 **응답**



자바에서는 오버라이딩으로 다형성을 구현

### 다형성의 본질

- **클라이언트를 변경하지 않고, 서버의 구현 기능을 우연하게 변경할 수 있따**



**결국 인터페이스를 안정적으로 잘 설계하는게 중요**



### **스프링과 객체 지향**

- 다형성이 가장 중요
- IoC, DI는 다형서을 활용해서 역할과 구현을 편리하게 다룰 수 있또록 지원
- 레고 블록 조립! 공연 무대의 배우 선택! 구현을 편리하게 변경할 수 있다.

---

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- 이걸 합쳐야 스프링에 대해서 !

---

## 3. SOLID

- SRP : 단일 책임 원칙(single responsibilty principle)
- OCP : 개방 폐쇄 원칙(Open/Close principle)
- LSP : 리스코프 치환 원칙 ( Liskov substitution principle)
- ISP : 인터페이스 분리 원칙 ( Interface Segregation principle)
- DIP : 의존관계 역전 원칙 ( Dependency inversion principle)



### SRP(single responsibilty principle)

- 하나의 클래스는 하나의 책임
- 책임이 뭔데?
  - **중요한 기준은 변경**
  - 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
  - UI변경, 객체의 생성과 사용을 분리!



### OCP, 개방 폐쇄 원칙(Open/Close principle) - 가장 중요

- 소프트웨어 요소는 **확장에는 열려, 변경에는 닫혀**
- 공연은 무명 배우가 해도 돼!
  - **다형성!**
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현!(기존 코드 변경 X)
  - 역할과 구현의 분리를 잘 생각해보자

#### 문제점

- MemberService가 구현 클래스를 직접 선택하고 있다
- **구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다**
- **분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없어(역할, 구현 만들었어)**
- 어떻게 해야해?
  - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요
  - 스프링이 해준다



### LSP : 리스코프 치환 원칙 ( Liskov substitution principle)

- 프로그램의 객체는 프로그램의 정확성을 꺠뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다

ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반. 즉 컴파일에는 문제는 없지만 핵심 기능은 변하지 않아야 한다



### ISP : 인터페이스 분리 원칙 ( Interface Segregation principle)

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스
  - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확, 대체 가능성이 높아짐



### DIP : 의존관계 역전 원칙 ( Dependency inversion principle)

- 프로그래머는 "추상화에 의존, 구체화의 의존 XX"
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- **역할(Role)에 의존**하게 해야하는 것과 같다
  - 운전자는, 자동차 역할만 알고 있어야지, K3인지, 어떤 차인지는 중요 X
  - 연극 극본에 집중해야지, 어떤 배우가 하는지는 대체 가능성 측면에서 매우 중요!
  - **구현에 의존하지 말자!!**
  - 대본에 집중해야하지 어떤 배우랑 따로 만들면 안 된다!



Cf) 의존한다?

- 내가 저 코드를 안다.
- in MemberService..

``` java
MemberRepository m = new MemoryMemberRepository();
```

- MemberService 클라이언트는 이미 메모리멤버리포지토리를 알아야만 기능 구현이 가능
- DIP 위반,



#### 요약

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발 X, 구현체가 없는걸 ㅠㅠ
- 구현 객체를 변경할 떄 클라이언트 코드도 함께 변경된다
- **다형성 만으로는 OCP, DIP 지킬 수 없다**
- 뭔가.. 더 필요해..

---

## 4. 객체 지향 설계와 스프링

스프링은 아래와 같은 기술을 활용해 **다형성 + OCP, DIP를 가능하게 지원**

- DI(Dependency Injection) : 의존관계, 의존성 주입
- DI 컨테이너 제공

**클라이언트의 코드 변경 없이 기능 확장**

코드로 직접 짜봐야, 나중에 원칙들을 지켜가며 DI 컨테이너!!



실무 고민

- 인터페이스를 도입하면 추상화라는 비용이 발생
- 기능을 확장할 가능성이 없으면, 구현 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법!!!



# 섹션 2. 스프링 핵심 원리 이해1 - 예제 만들기

해당 부분부턴 코드로 작업할 예정

cmd + , : preference



정책이 결정되기까지 개발을 무기한 연기 X

인터페이스로!!



객체 다이어그램은 실제 어떤걸 참조하는지 보여준다



cf) **enum은 상수 그룹**(final 변수처럼 바꿀 수 없는 변수)을 나타내는 특수한 "클래스". 열거형을 만들려면 class, interface 대신에 enum 키워드로 사용하고 상수를 쉼표로 구분,. 또한 대문자로

왜?

주석 없이도 의미 파악하기 위해서



# 섹션 3. 스프링 핵심 원리 이해 2, 객체지향 원리 적용

## 새로운 할인 정책 적용과 문제점(OCP, DIP)

요구사항 :  고정 금액 할인에서 정률% 할인으로 바꿈

인터페이스를 잘 설계했기 때문에 구현체만 바꾸고

Test를 하면 잘 된다

오 좋은 객체지향!



실제 코드를 보면 의존(그냥 클래스 이름이 나오면 의존한다는 느낌!!)

인터페이스에만 의존하도록 어떻게 만들까..?



**누군가** 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해야 한다!

---

## 관심사의 분리

- 애플리케이션을 하나의 공연이라고 생각
- 각각의 인터페이스를 배역(배우 역할)이라고 생각.
- 실제 배역에 맞는 배우를 선택하는건 누가?
  - 누가 할지 배우들이 직접 정하지 않는다..!!!
  - 현재 상황은 배우가 직접 공연도 해야하고, 누구랑 할지도 해야함
- 배우는 본인의 역할인 배역을 수행하는것만 집중해야함!(**다양한 책임**)
- 공연 구성, 담당 배우 섭외, 역할에 맞는 배우를 지정하는 "**공연 기획자**"가 나와야하는 시점
- 배우와 공연 기획자의 책임을 확실히 분리하자



프로젝트 상위단에 AppConfig.java를 만들어주고

해당 부분에서 서비스 관련된 이름들을 만들고

해당 부분에 어떤 객체를 쓸지, 즉 기획자 역할을 하는 클래스를 만들었다.



-> 그럼 이제 의존관계 없어짐..!!

객체의 생성과 연결은 AppConfig가 담당!!! => **DIP 완성**

- 추상에만 의존하게 된다.

**관심사의 분리** : 객체를 생성하고 연결하는 역할, 실행하는 역할과 명확히 분리!!



클라이언트인 MemberServiceImpl 입장에서는, 의존관계를 마치 외부에서 주입해주는 것 같다고!

**DI(Dependency Injection) : 의존관계 주입**



### 생성자 주입

- 인터페이스에만 의존하는 상황
- 생성자를 통해 어떤 구현 객체(인스턴스)가 들어올지는 알 수 없음..!
- 어떤객체가 주입이 될지는 AppConfig에서만 결정!!!!!!!!! 이제 실행에만 집중!



AppConfig는 구체 클래스를 전부전부 선택!!



기존에 너무 많은 책임이 있었던 각각의 Impl들을, AppConfig를 통해서 책임을 분리했다.

---

## AppConfig 리팩토링

``` java
public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
```

new MemoryMemberRepository() 라는 중복 코드를 위와 같이 함수로 제거했음

역할과, 구현 클래스가 한 눈에 들어오는 편. 애플리케이션 전체 구성을 빠르게 판단 가능

- 추후에 구현객체를 바꿀 때 해당 new 부분만 바꾸면 다 알아서 잘 바뀌게 된다는 장점이 있다.



SRP(Single Response polocy)

- appconfig 클래스를 통해 해결

### DIP의 의존관게 역전 원칙

- 프로그래머는 추상화에 의존, 구체화에 의존하면 안 된다.
- 의존성 주입은 이 원칙을 따르는 방법 중 하나.

OCP

- SW요소는 확정에는 열려 있으나 변경에는 닫혀 있어야.
- 클라이언트 코드 관점



SW 요소를 새롭개 확장해도, **사용 영역의 변경은 닫혀 있다!!!!**(변경할 필요가 없다)

---

## IOC, DI, 그리고 컨테이너

### 제어의 역전 IoC(Inversion of Control)

- 프레임워크가 대신 호출해줘
  - 예전에는 클라이언트 구현 객체가 서버 구현 객체를 스스로 생성하고, 연결하고, 실행
    - 제어 흐름을 스스로 조정
  - AppConfig 등장 이후 클라 구현 객체는 기능을 실행하는 역할만 함
  - 어떤게 호출될 지 모름(클라이언트 객체 입장, 제어권을 모두 AppConfig에 넣어줌)
- 프로그램에 대한 AppConfig가 객체 생성 권한을 다 가지고 있다.
- 프로그램의 제어 흐름을 직접 제어하는것이 아니라 외부에서 관리하는 것을 IoC



## 프레임워크 vs 라이브러리

ex) jUnit

- 그냥 해당 규칙을 맞추면, jUnit lifecycle 속에서 내것만 콜백으로 샵샵
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당하면 그것은 프레임워크가 아니라 라이브러리



### 의존 관계 주입

- OrderServiceImple은 DiscountPolicy 인터페이스에 의존(실제 어떤 구현 객체가 사용될지는 모름)
- 의존관계는 "**정적인 클래스 의존관계**와, **실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계"** 둘을 분리해서 생각



#### 정적인 클래스 의존관계

- 클래스가 사용하는 import 코드만 보고 어떤 객체가 사용되는지알 수 있다.

- 애플리케이션을 실행하지 않고도 그냥 분석이 가능!

#### 동적인 객체 인스턴스 의존 관계

- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계(실행시키기 전까지 모른다고)

**"객체 다이어그램"**

- 애플리케이션 **실행 시점(런타임)**에 외부에서 실제 구현 객체를 생성하고 클라이언트에게 전달해 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 "**의존관계 주입**"이라고 한다

- 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.



### IoC 컨테이너, DI 컨테이너

- AppConfig처럼 객체를 생성하고 관리하며 의존관계를 연결해주는 것을 
- IoC 컨테이너 혹은 **DI 컨테이너** 라 한다
- 의존관계 주입에 초점을 맞춰 DI 컨테이너라고 자주 사용함
- 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다
  - (스프링만 DI 하는거 아니다~~~~)

---

## 스프링으로 전환하기



AppConfig 스프링 기반으로 변경하기~



**"스프링 컨테이너"**

- ApplicationContext를 스프링 컨테이너라고 한다
- AppConfig를 직접 생성하는게 아니라 ApplicationContext, 즉 스프링 컨테이너를 통해서 사용
- 스프링 컨테이너는 @Configuration이 붙은 'AppConfig'를 설정(구성) 정보로 사용한다
  - @Bean 이라는 메서드를 모두 호출!!
  - 만환된 객체를 스프링 컨테이너에 등록함~!
  - 이렇게 스프링 컨테이너에 등록된 객체를 bean이라고 함
- 스프링 빈은 @Bean에 붙은 메서드명을 스프링 빈의 이름으로 사용
- 이제부터는 스프링 컨테이너를 통해 필요한 스프링 빈(객체)를 찾아야함
- applicationContext.getbean(name, class);
- 이제부턴 스프링 컨테이너에 객체를 스프링 빈으로 등록, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경!!



코드 복잡, 스프링 컨테이너를 사용하면 어떤 이점..??

- 어 마 어 마 함







강의시간 : 총 4시간(생각보다 코드 따라치고 모르는거 검색하면서 듣는게 오래걸린다. 화이팅)