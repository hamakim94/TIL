# 섹션 8. HTTP 헤더2 - 캐시와 조건부 요청





## 캐시 기본 동작

새로고침 -> 똑같이 이미지를 다운로드 받아야 함(헤더와 바디 부분을 다시 만들어서,.)



### 캐시가 없을 때

- 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운로드 받아야 한다
- 인터넷 네트워크는 매우 느리고 비싸다
- 브라우저 로딩 속도가 느리다
- 느린 사용자 경험



### 캐시 적용

- 헤더 부분에, **cache-control: max-age=60(유효 시간 : 초)**

- 2번째 요청 - 캐시에서 조회를 함. 네트워크를 ㅏ지 않음



- 캐시 덕분에 캐시 가능 시간동안 네트워크 사용 X
- 빠른 사용자 경험(위 4가지의 정 반대)



### 세 번째 요청 - 캐시 시간 초과

- 그럼 다시 요청 해야해..

- 응답 결과를 다시 캐시에 저장(덮어씌움)



- 캐시 유효 시간 초과 -> 서버를 통해 데이터 다시 조회, 캐시를 갱신
- 이때 다시 네트워크 다운로드가 발생함.



## 검증 헤더와 조건부 요청1

- 케시 유효 시간이 초과해서 서버에 다시 요청하면 다음 2 가지 상황
  1. 서버에서 기존 데이터 변경
  2. 서버에서 기존 데이터를 변경하지 않음



### 캐시 시간 초과

- 캐시 만료후, 서버에도 데이터를 변경하지 않음
- 데이터를 다시 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있을거야!
- 단, 클라이언트 데이터와 서버의 데이터가 같다는게 꼭 필요



### 검증 해더 추가 ( 처음 )

- 헤더 부분에, **Last-Modified : 2020년 11월 10일 10:00:00**
- 최종 수정일을 넣어두기

브라우저 캐시에서, 캐시 데이터에 최종 데이터 수정일~



요청할 때,  **if-modified-since : 2020년 11월 10일 10:00:00** 헤더 보내

서버에서 검증이 가능해짐!!!

수정이 안 되면, 304 Not Modified 라는걸로 보내(Last Modified 다시 보냄 -> **HTTP BODY가 없음.**.!!)



304 모디파이드네? 캐시 컨트롤값 갱신, 로컬 캐시에서 불러옴ㅁ



### 정리

- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면
- 304 Not Modified + 헤더 메타 정보만 응답(바디X)
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로 네트워크 다운로드 발생 용량이 적은 헤더 정보만 다운로드
- 매우 실용적인 해결책



구글 크롬 -> 200, 글씨가 연하면, 로컬 캐시에서 불러온 거, 만약 200을 

그럼 해당 이미지를 더블클릭 -> 해당 url로 새로 요청 -> 304가 뜬다..!!!! 신기신기!!

Last-modified , 다 있음!



## 검증 헤더와 조건부 요청2

- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - Last-Modified, ETag
- 조건부 요청 헤더
  - 검증 헤더로 저건에 따른 분기
  - If-Modified-Since: Last-Modified 사용
  - If-None-Match: ETag 사용
  - 조건이 만족하면 200OK
  - 만족하지 않으면 304Not Modified



### 예시

만약 바뀌었으면, 그냥 200 GET 요청으로 데이터 통째로 가져옴~



### 단점

LM, IMF

- 1초 미반 단위로 캐시 조정이 불가능(실제.. 과연?)
- 날짜 기반의 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우.
  - (a -> b -> a) 일 떄, 날짜만 갱신, 컨텐츠는 갱신X, 그런데도 다운로드가 발생할 수 있음
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
  - 예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우



### ETag(Entity tag)

- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
  - ETag: "v1.0"
- 데이터가 변경되면 이 이름을 바꾸어서 변경(Hash를 다시 생성)
  - ETag:"aaaaa" -> ETag: "bbbbb"
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!



서버에서 ETag 내려주고 -> 캐시에 ETag 값.

(유효 기간 지남) 브라우저에서 If-None_match: "aaaaaa" 보내

실패면 304(즉, 데이터가 안 변함), 0.1MB만전송, 내부적으로 케시 데이터 헤더 갱신~



### 정리

-  진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기!

- **캐시 제어 로직을 서버에서 완전히 관리**

- 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 매커니즘을 모름)

  

## 캐시와 조컨부 요청 헤더(정리)

- **Cache-Control: 캐시 제어**
  - ax-age : 캐시 유효 시간, 초 단위
  - no-cache : 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
  - no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
- Pragma: 캐시 제어(하위 호환)
- Expires: 캐시 유효 기간(하위 호환)





## 프록시 캐시

### 원 서버 직접 접근(origin server)

한국 -> 프록시 캐시 서버(한국 어딘가..) -> 미국에 있는 원서버



유튜브 -> 뭔가 해외에 마이너한 컨텐츠 -> 로딩속도 오래걸림 ㅋ

웹 브라우저 : private cache

CDN : public cache



### 캐시 지시어(directives) - 기타

- **Cache-Control:  public**

  - 응답이 public 캐시에 저장되어도 됨

- **Cache-Control: private (기본)**

  - 응답이 해당 사용자만을 위한 것, private 캐시에 저장되는 값(중요)

- Cache-Control: s-maxage

  - 프록시 캐시에서만 저장되는  max-age

  

## 캐시 무효화

### 확실한 캐시 무효화 응답

- **Cache-Control: no-cache, no-store, must-revalidate**
- **Pragma: no-cache(HTTP 1.0 하위 호환)** => 다 넣어야 해



브라우저 자체에서 GET요청할 떄 캐시하는 경우가 있어서, 명시해서 막을 때 사용하는게 필요하다!

(휴리스틱하게 캐싱이 일어난다.)





**no-cache vs must-revalidate**

no-cache

 ETag -> 프록시 캐시 (no cache 왔네) -> 원서버까지 요청이 감(검증)

no-cache : 프록시 캐시 서버가  원 서버에 접근할 수 없는 경우 캐시 서버 설정에 따라서 캐시 데이터를 반환할 수 있음, 오류 또는 오래된 데이터라도 보내주자!!) -> 200OK 까지 가능함(no-cache 정책)

즉, 프록시 캐시가 대신 응답 가능



must-revalidate

- 네트워크가 순간 단절, 원 서버 접근 불가
- 504 Gateway Timeout 을 꼭 보내야 함



그래서 다 만들어야 한다!!!!!!!









