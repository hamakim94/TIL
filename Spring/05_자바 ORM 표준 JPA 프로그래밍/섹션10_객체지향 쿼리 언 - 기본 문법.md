## 소개

### JPA는 다양한 쿼리 방법으 ㄹ지원

- **JPQL**
- JPA Criteria
- **QueryDSL**
- 네이티브 SQL
- JDBC API 직접 사용, 마이바티스, SpringJdpcTemplate





### JPQL 소개

- 가장 단순한 조회 방법
  - EntityManger.find()
  - 객체 그래프 탐색(a.getB().getC())
- 나이가 18살 이상인 회원을 모두 검색하고 싶으면?



- JPA -> 엔티티 객체 중심 개발
- 문제는 검색 쿼리
- 검색을 할 떄도 **테이블이 아닌 엔티티 객체를 대상으로 검색**
- 모든 DB데이터를 객체로 변환해서 검색하는 것은 불가능
- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요



- SQL 추상화 -> JPQL 객체 지향 쿼리 언어 제공
- SQL 문법과 유사
- JPQL은 엔티티 객체를 대상으로 쿼리
- SQL은 DB테이블을 대상으로 쿼리



- 특정 DB SQL에 의존 X
- **즉, 객체 지향 SQL**



### Criteria 

사실, 쿼리문이 단순한 String이다..(동적 쿼리 만들기 어려움)

- 중간중간 if문으로 String 더해서 조건 나눠야 해..
- 실무 0 ( 유지 보수 X )
- JPQL 빌더 역할, JPA 공식 기능, 자바 코드로 JPQL 작성 가능
- **QueryDSL 사용해라!**



### QueryDSL 소개

- 문자가 아닌 자바코드로 JPQL 작성
- JPQL 빌더
- 컴파일 시점에 문법 오류 찾을 수 있음
- 동적쿼리 작성 편리함
- **단순하고 쉬움**
- **실무 사용 권장**



### 네이티브 SQL 소개

- JPQ가 제공하는 SQL을 직접 사용
- JPQL 해결 X -> 특정 DB 의존적인 기능
- 오라클 CONNECT BY, 특정 DB만 사용하는 SQL힌트

### JDBC 직접 사용, SpringJdbcTemplate 등

- JPA를 사용하며 다른거 종합 가능
- **단, 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요**
- JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시



## JPQL(Java Persistence Query Language)

- 엔티티 객체를 대상으로 쿼리!
- 특정 DB 의존 X
- JPQL -> SQL로 변환!!



### JPQL 문법

- Update_절 (한 방에 여러번 할 떄, 기본 update는 그냥 엔티티로 다루면  OK)
- delete_절



- select m from **Member** as m where m.age > 18
- 엔티티와 속성은 대소문자 구분 O
- JPQL 키워드는 대소문자 구분 X(SELECT, where)
- 엔티티 이름 사용, 테이블 이름이 아님(Member)
- **별칭은 필수(m)**, (as는 생략 가능)

### 집합과 정렬

COUNT, SUM AVG, MAX, MIN 다 되고



GROUP BY, ORDER BY 똑같이



### TypeQuery, Query (클래스, 반환값)

- TypeQuery : 반환 타입이 명확할 때 사용
- Query : 반환 타입이 명확하지 않을 때 사용

```java
TypedQuery<Member> query1 = em.createQuery("select m from Member m", Member.class);
TypedQuery<String> query2 = em.createQuery("select m.username from Member m", String.class);
Query query3 = em.createQuery("select m.username, m.age from Member m");
```



### 결과 조회 API

- Query.getResultList() -> 컬렉션이 반환
  - 결과가 없으면 빈 리스트 반환(NullPointer XX)
- Query.getSingleResult() -> **결과가 정확히 하나**, 단일 겍체 반환
  - 결과가 없으면 : NoResultException
  - 둘 이상이면 : NoUniqueResultException



### 파라미터 바인딩 : 이름 기준 , 위치 기준

```java
TypedQuery<Member> query = em.createQuery("select m from Member m where m.username = :username", Member.class);
query.setParameter("username", "member2");
Member singleResult = query.getSingleResult();
System.out.println("singleResult = " + singleResult);

Member singleResult = em.createQuery("select m from Member m where m.username = :username", Member.class)
                    .setParameter("username", "member2")
                    .getSingleResult();
            System.out.println("singleResult = " + singleResult.getUsername());

```

위치 기준도 제공하지만, 쓰지 마





## 프로젝션

- select 절에 조회할 대상을 지정하는 것
- 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입)
  - SELECT **m** FROM Member m; -> 엔티티 프로젝션
  - SELECT **m.team** FROM Member m;  -> 엔티티 프로젝션
  - SELECT **m.address** FROM Member m; -> 임베디드 타입 프로젝션
    - 어디 소속인지 알아야 해!, 엔티티로부터 시작
  - SELECT **m.username, m.age** FROM Member m; -> 스칼라 타입 프로젝션
- DISTINCT로 중복 제거

생각보다 내용이 깊단다

- select 한 결과 -> 다 영속성 컨텍스트로 관리



### 프로젝션 - 여러 값 조회

SELECT m.username, m.age FROM Member m;

1. Query 타입으로 조회

2. Object[] 타입으로 조회

3. **new 명령어로 조회**

   - 단순 값을 DTO로 바로 조회

     SELECT new jpabook.jpql.UserDto(m.username, m.age) FROM Member m;

   - 패키지 명을 포함한 전체 클래스 명 입력
   - 순서와 타입이 일치하는 생성자 필요

```java
List<MemberDTO> result = em.createQuery("select new jpql.MemberDTO(m.username, m.age) from Member m", MemberDTO.class)
                    .getResultList();

            MemberDTO memberDTO = result.get(0);
            System.out.println("memberDTO.getUsername() = " + memberDTO.getUsername());
```

## 페이징 API -> ART

- JPA는 페이징을 다음 두 API로 추상화
- setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작)
- setMaxResults(int maxResult) : 조회할 데이터 수



cf) toString -> 양방향 주의..!!

각 방언마다 다르게 된다~



## 조인

- 내부 조인
  - SELECT. m FROM MEMBER m [INNER] JOIN m.team t
- 외부 조인
  - SELECT. m FROM MEMBER m LEFT [OUTER] JOIN m.team t
- 세타 조인
  - select count(m) from Member m, Team t where m.username = t.name
  - 카타시안 곱



### 조인 0 On절

- JPA 2.1 부터 지원
  1. 조인 대상 필터링
  2. 연관관계 없는 엔티티 외부 조인(하이버네이트 5.1부터)

#### 1. 조인 대상 필터링

- 회원과 팀을 조인하면서, 팀 이름이 A인 팀만 조인
  - SELECT m, t FROM Member m LEFT JOIN m.team t on t.name = 'A'

#### 2. 연관관계 없는 엔티티 외부 조인

- 회원의 이름과 팀의 이름이 같은 대상 외부 조인
  - SELECT m, t FROM Member m LEFT JOIN Team t on m.username = t.name





## 서브 쿼리

- 나이가 평균보다 많은 회원
  - select m from member m where age > (select avg(m2.age) from Member m2)

- 한 건이라도 주문한 고객

  - select m from Member m

    where (select count(o) from Order o where m=o.member) > 0



### 서브 쿼리 지원 함수

- EXISTS
  - {ALL | ANY | SOME} subquery
  - any == some
- IN



### JPA 서브 쿼리 한계

- JPA는  WHERE, HAVING 절에서만 서브 쿼리 사용 가능
- SELECT 절도 가능(하이버네이트에서 지원)
- **FROM 절의 서브 쿼리(인라인 뷰)는 현재 JPQL에서 불가능**
  - **조인으로 풀 수 있으면 풀어서 해결**



너무 쓰고싶으면 native sql, 그런데 사실 애플리케이션에서 직접 조작 or 쿼리 분할 , 애플리케이션 조합



## JPQL 타입 표현

- 문자:  'HELLO' 'She''s'
- 숫자 : 10L, 10D, 10F
- Boolean : TRUE FALSE
- ENUM : jpabook.MemberTupe.Admin(패키지명 포함)
- 엔티티 타입 : TYPE(m) = Member ( 상속 관계에서 사용 )



### JPQL 기타

- SQL 문법이 같음
- EXISTS, IN
- AND, ㅒOR, NOT
- \>=, ==, 등
- BETWEEN, LIKE, **IS NULL**



## 조건식 - CASE식

기본 CASE식, 단순 CASE 식

- COALESCE : 하나씩 조회해서 null이 아니면 반환
- NULLIF: 두 값이 같은면 null 반환, 다르면 첫번째 값 반환
  - 관리자면 null 반환, 나머진 본인 이름 반환(관리자 감추기)

```java
String query =  "select " +
                    "case when m.age <= 10 then '학생요금' " +
                    "     when m.age >= 10 then '경로요금' " +
                    "     else '일반요금' end " +
                "from Member m ";
List<String> result = em.createQuery(query, String.class).getResultList();
for (String s : result) {
    System.out.println("s = " + s);
}
```



## JPQL 기본 함수

- CONCAT
- SUBSTRING
- TRIM
- LOWER, UPPER
- LENGTH
- LOCATE
- ABS, SQRT, MOD
- SIZE, INDEX(JPA 용도)



### 사용자 정의 함수 호출

여기서 막 안 돼!

- 하이버네이트틑 사용 전 방언에 추가

  - 사용하는  DB 방언을 상속받고, 사용자 정의 함수 등록
  - 실제로, 함수 쓸 일이 많음..!!

- 함수를 만들어 놨다고 가정~

  



