# 섹션 6, 주문 도메인 개발



## 주문, 주문상품 엔티티 개발

굉장히 중요

entity 내에 실제 비즈니스 로직이 있음

실제로 어떻게 비즈니스 로직이 되는지 확인!!



보통 entity 안에서 **비즈니스 로직**, **생성 메서드**, **조회 로직**을 주석 처리해서 보기 쉽게 

- 생성 메서드를 따로 빼는 이유는, 복잡한 객체를 만들면서 필요한 의존성이라던지 쉽게 설정하기 위해서 따로 createMethod를 만들어서 사용하기 쉽게 하기 위함



## 주문 리포지토리 개발

저장(save)

하나 찾기(findOne)

검색 -> 동적 쿼리 사용 -> 나중에





## 주문 서비스 개발

cascade 걸려 있어서, order 만들 떄 나머지들도 다 persist가 자동으로 된다

 cascade의 범위는, 딱 주인이 명확한 경우(다른 곳에서 막 갖다 쓰지 않음.)  특정 데이터를 한 싸이클에서 쓰면 OK

만약 주인 명확 X, 다른 곳에서 막 씀 -> 쓰지 마! 리포지토리 따로 만들기



다른 생성자로 만드는걸 막기 위해@NoArgsConstructor(access = AccessLevel.PROTECTED) 하면 new -> set, set 해서 못 만듬



**도메인 모델 패턴** : 서비스 계층은 단순히 엔티티에 필요한 요청을 위함하는 역할

(엔티티 안에 복잡한 비즈니스 로직이 많다.)



**트랜잭션 스크립트 패턴 : 다 서비스 계층에 있을 떄**



## 주문 기능 테스트

- 상품 주문이 성공해야 함
- 주문 취소
- 주문할 때 재고수량 .

재고수량 관련에 있어서, 엔티티 안에서 단위 테스트를 만드는게 더 효율적, 서비스 테스트에서 객체 만들고 .... 하는건 너무 범위가 큼

도메인 모델 패턴에서는 엔티티 자체에서 단위 테스트 가능한 장점이 있따.



## 주문 검색 기능 개발

동적 쿼리를 지양하지만... 동적 쿼리를 쓰면 유용한 경우가 많음 -> JPA에서는 어떻게 쓸까!

- 방법 1(사용 X)

  - 문자열로만 접근 : 헬. 너무 지옥(코드 길이 너무 길다)

  - **동적 쿼리 작성이 쉬운 이유로 mybatis나 ibatis를 이용한다.**

- 방법 2(사용 X)

  - JPA Criteria

- 방법 1, 2 : 모두 어떤 JPQL이 되는지 안 보인다. ( 의미를 파악, 유지보수 XXXX )

- **방법 3, QueryDSL**

  - 굳!



