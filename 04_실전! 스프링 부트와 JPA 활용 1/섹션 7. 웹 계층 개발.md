# 홈 화면과 레이아웃



타임리프 페이지 -> docs -> layout 사용하기

include형과 계층형!



## 회원 등록

javax @Valid 쓰면 내가 만들었떤 @NotEmpty, 등 필드에 대한 설정을 검증이 가능하다.



BindingResult class를 파라미터에 넣으면, 오류 났을 때 어떻게 할 수 있을 지 정할 수 있다

타임리프 : 스프링이랑 잘 연동 -> 할 수 있는 기능이 많다



왜 멤버 엔티티 딱 안 넣어? 비슷하잖아!

- 벨리데이션, 코드 지저분,
- 컨트롤러에서 화면에서 넘어올 떄 validation이랑, 내부 logic validiation이 다를 수 있다.!
  - 필요한 데이터만 따로 객체 만들어서 하는걸 추천한다!



## 회원 목록 조회

단순

타임리프 장점이 많다~

- ? 옵션 -> nullable



**JPA : 엔티티 자체는, 최대한 순수, 비즈니스 로직! 무조건!**

화면에 맞는 로직  XXXXX, 이럴 떈 폼 객체나, DTO 사용해요!



**API 만들 떈 엔티티를 절대로 그대로 넘기면 안 돼**

- API : 스팩
- 엔티티에 필드 하나 추가하면..!! -> API 스펙 자체가 변해버림..!!
- SSR은 ㄱㅊ은 편.
- 하지만 화면용 DTO를 만드는걸 추천하는 편!



## 상품 등록

잘 안 되는 부분들이 있었다.

id가 꼭 필요한데. id 필드가 없어서 생긴 문제 같기도..?

**사실 set을 너무 잘 쓰면 안 돼, static 생성자 메서드를 통해 바로 만드는게 좋다**



**Transaction Readonly 문제점이 있다**

- DB에 반영이 잘 안 된다 -> 트랜잭션 관리 문제라고 생각해보기
- service나 repository에서 트랜잭션 어노테이션을 본다고 생각



## 상품 목록



## 상품 수정

서버 쪽에서

수정할 떄 , 유저가 이 객체에 대한 접근 권한이 있는지 확인해봐야 한다.!!

- item의 id가 null이 아니니까
  - merge를 사용한다(JPA)
  - 사실 실무에서 쓸 일이 없다!



## \*\*변경 감지와 병합(merge)\*\*

**정말정말 중요하다!**

### 준영속 엔티티

- 영속성 컨텍스트가 더는 관리하지 않는 엔티티
  - (itemService.saveItem(book))에서 수정을 시도하는 Book 객체
  - 이 객체는  이미 DB에 한 번 저장돼 **식별자**가 존재한다
  - 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다.

### 준영속 엔티티를 수정하는 2가지 방법

- 변경 감지 기능 사용
- 병합(merge) 사용

@Transactional 은 해당 코드가 다 끝나면 commit을 날림 -> JPA FLUSH 작동 -> 변경된 부분 감지해서 알아서 바꿔줌  



#### 변경 감지 기능

- 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정(id기반  DB에서 하나 찾아옴)
- 트랜잭션 안에서 엔티티를 다시 조회, 변경할 값 선택 -> 트랜잭션 커밋 시점에 변경 감지(dirty checking)이 동작해서 데이터베이스에 UPDATE SQL 실행

#### 병합 사용

- 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능

동작 방식(참고)

- merge 실행
- 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회
  - 만약 1차 캐시에 없으면, DB에서 조회하고, 1차 캐시에 저장
- 조회한 영속 엔티티에 파라미터 엔티티의 값을 채워 넣음
- 바뀐 값을 반환함..!



3줄 요약(병합)

- 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회한다
- 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체한다(병합한다
- 트랜잭션 커밋 시점에 변경 감지 기능이 동작, DB에 Update Sql 실행)

**주의!** : 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경. 병합시 값이 없으면 null로 업데이트 할 위험도 있다.



### 변경 감지만 사용(merge 쓰지 마)

+ 컨트롤러에서 어설프게 엔티티 만들지 마
+ 트랜잭션이 있는 서비스 계층에 식별자(id)와 변경할 데이터만 명확하게 전달(파라미터  or DTO)
+ 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티 조회, 엔티티의 데이터를 직접 변경
+ 트랜잭션 커밋 시점에 변경 감지

특정 시점에서 setter를 활용해서 엔티티를 변경하는 것 보다

엔티티 자체에서 메서드를 만들어서(change) 사용하는게 훨씬 유지보수성이 좋다



## 상품 주문

멤버, 아이템이 다 필요함 -> 의존성이 많음. 잘 활용해보자

컨트롤러의 로직은 최대한 간단하게, Service에는 id(식별자, 기본키)를 넘겨줘서, 안에서 찾는게 더 할 수 있는게 많아진다.

@Transactional 안에서 findOne을 해야 영속성!

- dirty checking 적용 가능!!

파라미터에서 객체가 직접 넘어 오면 영속성 context가 아니다, 값을 바꾸기 어려워지는 부분이 많이 생긴다..!!



## 주문 목록 검색/취소

@ModelAttribute : 자동으로 담긴ㅂ

