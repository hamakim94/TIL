# 섹션4_컬렉션 조회 최적화



## V1 주문 조회: 엔티티 직접 노출

@ToOne -> 그냥 fetch join 하면 ok

하지만 @xxxToMany 0-> 중복 포인트가 많이 생겨서 문제가 생김



주문 내역에서 추가로 주문한 상품 정보를 추가로 조회하자

order -> orderItem



굳이 getName, 이런거 출력하는 이유는

프록시 내에 데이터 초기화를 위해서다





## V2 주문 조회: 엔티티를 DTO로 변환

이제 엔티티 직접 노출 X -> DTO로 변환해보자~

**DTO 만들어서 orderItems -> null이 나오네!?**

- 엔티티니까!
- 프록시 초기화 해주자

그런데, orderItems..!! 자체가 엔티티!

- 그럼 OrderItem 자체도 DTO를 만들어야..!!!!



쿼리 자체가 끔찍하게 많이 나옴

order -> member, delivery -> orderItem(2번)

order -> member, delivery -> orderItem(2번)

collection을 쓰면 최적화에 대해서 특히 고민을 많이 해야한다..



## V3 주문 조회: 엔티티 DTO - 페치 조인 최적화

join fetch 막 하면, DB 입장에서, 매우 중복되는 상황이 많이 발생하게 됨



DB의 DISTNCT는 나머지 필드까지 전부 똑같아야지 할 수 있음

그런데 JPA distinct 키워드는,

order가 같은 id값이면 중복을 제거해줌(하나 버림), 리스트 반환해서 버림



``` java
// OrderRepository
    public List<Order> findAllWithItem() {
        return em.createQuery(
                        "select distinct o from Order o " +
                                " join fetch o.member m" +
                                " join fetch o.delivery d" +
                                " join fetch o.orderItems oi" +
                                " join fetch oi.item i", Order.class)
                .getResultList();
    }
```

- sql 한 번
- application에서 추가 중복을 걸러줌(distinct), 일대다여서 발생한 문제

단점

- **페이징 불가능**
- 일대 다를 fetch join -> 페이징 쿼리가 안 나감
  - LIMIT, OFFSET 안 보여..(setFirstResult, setMaxResult)
  - 메모리에서 소팅해줄게..!!(!! 전부 메모리에서 한다고,.!?!?)

이미 조인 해놨어 -> 중복, 즉 페이징 처리가 애매해

(fetch join -> application단에서 중복. 처리를 해주기 때문에..!)

**일대다 -> 페이징 hard*=**

- 컬렉션 페치 조인 -> **페이징 불가능!**
- **컬렉션 패치 조인은 1개만 사용할 수 있따**. 컬렉션 둘 이상에 페치 조인 사용 -> 데이터 부정합하게 조회될 수 있음..



## V3.1 주문 조회 : 엔티티 DTO - 페이징과 한계 돌파



### 페이징과 한계 돌파

- 컬렉션을 패치 조인 -> 페이징 불간으
  - 일대 다 조인 -> 데이터가 예측할 수 없이 증가
  - 일대다 -> 일을 기준으로 페이징을 하는 것이 목적
  - 데이터는 다(N) 기준으로 row가 생성돼
  - Order기준 페이징 -> 다(OrderItem) 기준으로..
- 이 경우 하이버네이트는 경고 로그 -> DB 데이터 다 읽어서 메모리에서 페이징을 시도(최악의 경우 장애)



### 한계 돌파

- 페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야할까?
- 코드 단순 + 성능 최적화까지..?
  - 사실, 다른 방법 XX



1. XXXToOne -> 모두 페치 조인(row 수 증가 X)
2. 컬렉션은 지연 로딩으로 조회
3. 지연로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size.= true, @BatchSize' 이용(application.yaml 에 작성)
   - hinernate properties 아래
   - @BatchSize : 개별 최적화
   - 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size만큼 IN쿼리로 조회
4. 1, n, m 이 1, 1, 1이 되버림(쿼리의 수)



- 1번 단계 스킵하고 그냥 application에 설정만 해놓고 XXXToOne은 안 해놓으면, 기존 join 하던거 다 따로 select, select -> 네트워크 많이 탐
- 상황에 따라 V3, V3.1 어떤게 좋은지 다르다



글로벌하게 말고, 디테일하게 하면, @OneToMany 필드에 @BatchSize에 넣아야함

컬렉션이 아닌경우는, 클래스 이름에 딱 넣는다

결론은, 글로벌하게 설정하는게 편하긴 하다!!



### 정리

- 장점
  - 쿼리 호출 수 1 + N -> 1 + 1
  - 조인보다 DB 데이터 전송량이 최적화
  - 페지 조인 방식과 비교해서 쿼리 호출수는 많지만, DB 데이터 전송량이 감소
  - **컬렉션 페치 조인은 페이징 불가능, 이 방법은 페이징 가능**
- 결론
  - ToOne -> 페치 조인 OK
  - 나머지는 hibernate.default_batch_fetch_size 이용
- 배치 사이즈?
  - 100~1000 사이를 권장
  - 이 전략은 SQL IN 절 사용
  - DB마다 in 파라미터 개수 다름
    - 사실 1000이 이론상 가장 좋긴 한데
    - DB에서 애플리케이션으로 순간적으로 데이터를 확 땡김
    - DB / App 둘 다 순간적으로 부하 증가
  - 100개 설정 -> DB, APPlcation이 조금 조금 다다다다다다 한다(부하 준다. 대신 시간은 오래 걸림 ㅋ)

WAS VS DB -> 100정도 넣고 써보면서 증가~

WAS 입장에서는 10, 1000이든 결국 DB 긁어오는 개수는 똑같아서 의미 X



