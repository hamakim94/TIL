## 25강_데이터베이스 객체

### 1. 데이터베이스 객체

정의 : 테이블이나 뷰, 인덱스 등 데이터베이스 내에 정의하는 **모든 것**

실체를 가지는 어떤 것



#### cf) 객체 이름 규칙

- 기존 이름, 예약어와 중복 X
- 숫자로 시작 X
- 언더스코어(_) 외 기호 사용 X
- 한글 -> 더블쿼트("")(MySQL - 백쿼트(''))로 둘러쌈
- 시스템이 허영한 길이 초과 X
  - **의미 없는 이름을 붙이지 않도록**



### 2. 스키마

DB객체는 스키마라는 그릇에 담김

객체 이름이 같아도 다른 스키마면  OK

DB객체는 스키마객체라고도 불린다

- 데이터베이스에서 테이블 작성해 구축 -> '스키마 설계'

#### cf) 네임스페이스 

- 이름이 중복되지 않도록 기능하는 그릇
- 스키마, 테이블 모두 네임스페이스!



## 26강_테이블의 작성,삭제,변경 - DDL

``` sql
-- SYNTAX
CREATE TABLE 테이블명(열 정의 1, 열 정의 2, ...)
DROP TABLE 테이블명
ALTER TABLE 테이블명 하부명령
```

### 1. 테이블 작성

DDL -> 모두 같은 문법 사용 ( CREATE TABLE, CREATE VIEW 등)

``` sql
열명 자료형 [DEFAULT 기본값] [NULL | NOT NULL]
```

### 

### 2. 테이블 삭제

**DROP TABLE 테이블명으로 삭제 가능, 그렇지만 주의하자!**

테이블 정의를 그대로 둔 채 데이터만 삭제 -> DELETE 명령어

DELETE는 복잡, 테이블 내 데이트 전부 **빠르게**  삭제 -> **TRUNCATE TABLE 테이블명**



### 3. 테이블 변경

``` mysql
-- SYNTAX
ALTER TABLE 테이블명 변경명령
```

ALTER의 크게 두 가지 기능

- 열 추가, 삭제, 변경
- 제약 추가, 삭제



#### 열 추가 : ADD 하부명령

``` sql
ALTER TABE 테이블명 ADD 열 정의
-- ALTER TABLE sample ADD newcol INTEGER
```

cf) NOT NULL 제약이 걸린 열을 추가 -> 기본값을 지정해야..!



#### **열 속성 변겅** : MODIFY 하부명령

``` sql
-- SYNTAX
ALTER TABLE 테이블명 MODIFY 열 정의
-- ALTER TABLE sample MODIFY newcol VARCHAR(20);
```

- 열 속성 바뀌면 테이블에 들어간 데이터의 자료형 역시 바뀌고
- 하나라도 안 되면 ALTER 명령이 먹히질 않음
  - ALTER -> 비교적 새로운 명령, 각 DB마다 다를수도

#### 열 이름 변경 : CHANGE 하부명령

``` sql
-- SYNTAX
ALTER TABLE 테이블명 CHANGE [기존 열 이름] [신규 열 정의]
```

cf) oracle -> RENAME TO 하부명령 한다

#### 열 삭제 : DROP 하부명령

``` sql
-- SYNTAX
ALTER TABLE 테이블명 DROP 열명
```



### 4. ALTER TABLE로 관리

실무에서 자주 사용할 2가지 경우

- 최대 길이 연장
- 열 추가



## 27강_제약

### 1. 테이블 작성시 제약 정의

``` sql
CREATE TABLE sample (
	a INTEGER NOT NULL,
	b INTEGER NOT NULL UNIQUE, -- 열 제약
	c VARCHAR(30),
  PRIMARY KEY (a, b) -- 테이블 제약
);
```

NOT NULL, UNIQUE -> **열 제약**

복수의 열에 제약 설명 -> **테이블 제약**



**제약에는 이름을 붙일 수 있다**

```sql
CREATE TABLE sample2(
	no INTEGER NOT NULL,
	sub_no INTEGER NOT NULL,
	name VARCHAR(30),
	CONSTRAINT pkey_sample PRIMARY KEY (no, sub_no)
);
```



### 2. 제약 추가

**\- 열 제약 추가**(ALTER- MODIFY)

```sql
ALTER TABLE sample MODIFY c VARCHAR 30 NOT NULL;
```

**\- 테이블 제약 추가**(ALTER - ADD)

``` sql
ALTER TABLE sample2 ADD CONSTRAINT pkey_exam PRIMARY KEY(a);
```



### 3. 제약 삭제

``` sql
-- 열 제약 삭제
ALTER TABLE sample MODIFY c VARCHAR(30) -- NOT NULL 삭제
-- 테이블 제약 삭제
ALTER TABLE sample2 DROP CONSTRAINT pkey_exam
ALTER TABLE sample2 DROP PRIMARY KEY -- 테이블당 하나만 설정할 수 있는 기본 키이기에 가능
```



### 4. 기본키 ***********************

``` sql
-- 테이블 예시
CREATE TABLE sample3(
	p INTEGER NOT NULL,
	a VARCHAR(30),
	CONSTRAINT pkey_sample3 PRIMARY KEY (p)
);
```

기본키?

- **테이블 당 한 개를 특정할 수 있는 검색키(중 복 X )**

**기본키 제약**

- 열을 기본키로 지정해 유일한 값을 가지도록 하는 구조
- Update 중복값, insert 중복값 하면 오류



#### cf) 복수의 열로 기본키 구성하기

여러 열을 기본키로 -> 해당 열들을 모두 사용해 중복을 비교



## 28강_인덱스 구조 - 매우 중요

### 1. 인덱스

**색인**- 검색 속도의 향상 (SELECT - WHERE로 원하는 조건 찾기)
영어사진의 A,B,C 순으로 돼있는거라고 생각(그래야 A로 시작하는 단어 빨리 찾기)

### 2. 검색에 사용되는 알고리즘

**이진 트리**

**\- Full Table Scan**

- 데이터 전체 순회(1000개 -> 최대 1000번 수행)

**\- 이진 탐색(Binary Search)**

- 1~100 까지 이루어진 자료애서, 70 찾고 싶다
  - (1+100) / 2 = 50, 50번쨰보타 값이 크네?
  - (50 + 100) / 2 = 75, 75보다 작네? (오른쪽 수정)
  - (50 + 75) / 2 = 62, 62보다 크네? ( 왼쪽 수정)
  - (62 + 75) / 2 = 68, 68보다 크네? (왼쪽 수정)
  - (68 + 75) / 2 = 71, 71보다 작네? (오른쪽 수정)
  - (68 + 71) / 2  = 79, 69보다 크네 ? (왼쪽 수정)
  - **(69 + 71) / 2 = 70. 찾아!**
- 원래 1~70까지 총 70번의 연산을, 8번만에 완료!

**대량 데이터 탐색 -> 이진 탐색이 빠름(전제 : 정렬)**



### 3. 유일성

**이진트리에는 중복하는 값을 등록할 수 없게 설정**



## 29강_인덱스 작성과 삭제

``` SQL
-- SYNTAX : DDL 사용
CREATE INDEX
DROP INDEX
```



### 1. 인덱스 작성

**CREATE INDEX 명령**

DB객체가 될지, 테이블의 열처럼 취급될지는 DB제품마다 다름

- (스키마 객체 OR 인덱스 테이블 내 객체)

``` sql
-- SYNTAX
CREATE INDEX 인덱스명 ON 테이블명(열명1, 열명2, ...)
```

너무 많이 행이 있을 때 인덱스를 만들면 시간 오래걸리고 메모리도 많이 잡아먹음



### 2. 인덱스 삭제

``` sQl
DROP INDEX 인덱스명 -- (스키마 객체)
DROP INDEX 인덱스명 ON 테이블명 -- (테이블 내 객체)
```

DROP TABLE 해도 인덱스는 자동으로 삭제돼



### 3. EXPLAIN

``` sql
-- SYNTAX
EXPLAIN SQL명령;
```

- 표준 SQL 아님 -> 다른 DB도 이와 비슷한 명령 있음



### 4. 최적화

SQL 명령 내리기 전에 미리 계획을 짠다

꼭 인덱스가 필요할까?

- 만약 데이터 형테가 0, 1로만 이루어 있다면, 인덱스가 딱히 필요 없다



## 30강_뷰 작성과 샂게

``` SQL
-- SYNTAX
CREATE VIEW 뷰명 AS SELECT 명령
DROP VIEW 뷰명
```

서브쿼리에 이름을 붙이고 데이터베이스 객체처럼 만들어 쉽게 사용하는게 VIEW



### 1. 뷰

**너무 긴 SELECT 명령이 있어 -> DB객체로 관리해서 편하게 사용할래! -> VIEW**

**뷰는 SELECT 명령을 기록하는  DB 객체!**

**\- 가상 테이블**

- 실체가 존재하지 않는다
- 테이블처럼 취급이 가능해도, 데이터를 쓰거나 지울 수 있는 저장공간은 없음
- SELECT 명령에서만 사용하도록!



### 2. 뷰 작성과 삭제

뷰의 열 지정도 할 수 있음

``` sql
-- SYNTAX
CREATE VIEW 뷰명 (열명1, 열명2, ...) AS SELECT 명령
```

잘 쓰지 않는다.



**\- 뷰 삭제**

DROP 뷰



### 3. 뷰의 약점

저장공간 소비 X -> **CPU 자원 사용**

처리속도 적으ㅡㅁ

**\- 머터리얼라이즈드 뷰(Materailzed VIew)**

- 데이터 일시 저장 -> 쿼리가 종료될 때 함꼐삭제
- 테이블처럼 저장장치에 저장해두고사용함
- ORACLE, DB2에서만 사용 가능(MySQL XX)



**\- 함수 테이블**

- SELECT 명령이 단독으로만 사용 가능
- 테이블을 결과값으로 반환해주는 사용자정의 함수
- 인수 지정 -> 상관 서브쿼리처럼 사용 가능
- 알아만 두자
