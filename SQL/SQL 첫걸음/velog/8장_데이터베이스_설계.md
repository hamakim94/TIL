## 34강_데이터베이스 설계

테이블 정의서, ER다이어그램을 읽는 방법



### 1. 데이터베이스 설계

스키마 내에 테이블, 인덱스, 뷰 등의 DB객체 정의 -> 스키마 정의라고도 함

**\- 논리명과 물리명**

일반적인 테이블 정의서, 설계도

**테이블명(물리명) : product , 상품 논리명 : 상품마스터**

| 열명     | 자료형      | NULL | 기본값 | 비고 |
| -------- | ----------- | ---- | ------ | ---- |
| 상품코드 | CHAR(4)     | No   |        |      |
| 상품명   | VARCHAR(30) | Yes  |        |      |
| 가격     | INTEGER     | Yes  |        |      |

DESC 명령과 같음

- 물리명 CREATE TABLE product
- 논리명 : 설계상 이름(상품마스터)



**\- 자료형**

기본: 수치 자료형, 제조번호 : 문자열 자료형(문자 -> 숫자는 에러 많이 발생)

CHECK제약을 통해 0,1밖에 안 들어가는 범주형 데이터 정합성 챙기기

만약 0이 남성, 1이 여성이면 비고란에 적어두는게 좋다



**\- 고정길이와 가변길이**

열에 저장할수 있는 크기는 고작 수 천 바이트

이럴떈 LOB(Large Object) 자료형 사용(인덱스 지정 불가)



**\- 기본키**

기본키 지정 열 생각 X -> 자동증가 열 사용(INSERT 등)

PRIMARY KEY, UNIQUE로 유일성은 지정해야해!



### 2. ER 다이어그램 예시

``` mermaid
erDiagram
    PRODUCT {
    		char(5) product_code
        char name
        char(5) maker_code
				INTEGER price
    }
    MAKER {
    	char(5) maker_code
    	varchar(20) maker_name
    }
    MAKER||--|{  PRODUCT : maker_code 


```

- 일대일
  - 말 그대로 하나가 정해지면 다른 하나도 정해질 때 
- 일대다, 다대일
  - 1 : N
    -  특정 객체가 여러개의 다른 객체의 레퍼런스를 갖고 있을 때, 나는 하난데 상대는 여러개)
    - 메이커 하나의 여러개의 상품이 있을 수 있음 -> OneToMany(일 대 다)
  - N : 1
    - PRODUCT 입장에는 MAKER 하나만 가질 수 있음
    - MAKER 입장에선 다대일
- 다대다
  - 자주 사용하지 말자.



## 35강_정규화

DB 설계 단계에서 진행 || 기존 시스템 재검토

관계형 DB가 효율적으로 동작하도록 만든 지침

### 0. 정규화 테이블 예시

| 주문번호 | 날짜 | 성명   | 연락처    | 주문상품                 |
| -------- | ---- | ------ | --------- | ------------------------ |
| 1        | 1/1  | 해삼   | 010-xxxx. | 0001 OO 1개, 0002 XX 2개 |
| 2        | 2/1  | 멍개   | 010-xxxx. | 0001 OO 2개, 0002 XX 3개 |
| 3        | 2/5  | 말미잘 | 010-xxxx. | 0001 OO 3개, 0003 TT 1개 |

### 1. 제1 정규형

DB : 하나의 셀에는 하나의 값만 저장

주문 상품을 상품코드, 상품명, 개수 로 나눠!

#### 1단계 : 반복되는 데이터를 세로 방향(행 방향)으로 늘려

| 주문번호 | 날짜 | 성명   | 연락처    | 상품코드 | 상품명 | 개수 |
| -------- | ---- | ------ | --------- | -------- | ------ | ---- |
| 1        | 1/1  | 해삼   | 010-xxxx. | 0001     | OO     | 1    |
| 1        | 1/1  | 해삼   | 010-xxxx. | 0002     | XX     | 2    |
| 2        | 2/1  | 멍개   | 010-xxxx. | 0001     | OO     | 2    |
| 2        | 2/1  | 멍개   | 010-xxxx. | 0002     | XX     | 3    |
| 3        | 2/5  | 말미잘 | 010-xxxx. | 0001     | OO     | 3    |
| 3        | 2/5  | 말미잘 | 010-xxxx. | 0003     | TT     | 1    |

####  2단계 : 테이블 분할(행 중복 제거) + 기본키 지정!

주문번호, 날짜, 성명, 연락처가 행마다 겹치지

주문 테이블

| 주문번호 | 날짜 | 성명   | 연락처    |      
| -------- | ---- | ------ | --------- | 
| 1        | 1/1  | 해삼   | 010-xxxx. |
| 2        | 2/1  | 멍개   | 010-xxxx. |
| 3        | 2/5  | 말미잘 | 010-xxxx. | 

주문상품 테이블

| 주문번호 |  상품코드 | 상품명 | 개수 |
| -------- | -------- | ------ | ---- |
| 1        | 0001     | OO     | 1    |
| 1        | 0002     | XX     | 2    |
| 2        | 0001     | OO     | 2    |
| 2        |  0002     | XX     | 3    |
| 3        | 0001     | OO     | 3    |
| 3        |  0003     | TT     | 1    |

주문 테이블 -> 주문 테이블을 기본키로 지정 가능!



### 2. 제2 정규형

####  부분 함수 종속성(키 값을 사용하여 데이터를 특정지을 수 있는 것) 제거

기존 주문상품 테이블에서, **주문번호 + 상품번호가 기본키**

상품코드 -> 상품명, 특정 지을 수 있다. 

상품 테이블을 따로 만들면 좋겠다

**상품 테이블**

| 상품코드 | 상품명 |
| -------- | ------ |
| 0001     | OO     |
| 0002     | XX     |
| 0003     | TT     |

이렇게 만들면 주문상품 테이블의 상품명 열이 필요 없겠지!





### 3. 제3 정규형

#### 기본키 이외의 부분에서 중복이 없는지

주문 테이블 -> 고객의 성명과 연락처 -> 따로 고객 테이블 만들 수 있을 것 같아

주문 테이블의 기본키 -> 주문 번호, 고객과 관련이 없다.

**고객 테이블**

| 고객번호 | 성명   | 연락처    |
| -------- | ------ | --------- |
| 1        | 해삼   | 010-xxxx. |
| 2        | 멍개   | 010-xxxx. |
| 3        | 말미잘 | 010-xxxx. |

-> 이를 통해 주문 테이블에 고객 번호 열을 만들어 고객테이블 기본키를 참조하면 OK



#### cf) in ERD..

- 네모난 상자(엔티티) - 테이블
- 선이 연계(릴레이션십



### 4. 정규화의 목적

**하나의 데이터가 한 곳에 저장되도록!**

이외에도 더 높은 단계의 정규화가 있지만, 정규화를 너무 하면 검색 속도가 오히려 느려질 수 있다



## 36강_트랜잭션

``` sql
-- SYNTAX
START TRANSACTION
COMMIT
ROLLBACK
```

### 1. 트랜잭션

주문 테이블 , 주문상품 테이블 생각

**주문을 했으면, 주문상품도 꼭 있어야지!! 주문한 상품이 없는데 주문?**



**\- 주문이 발생하면?**

- 주문 번호 지정
- 해당 키를 삼아 INSERT가 이루어짐(주문상품 테이블에)
- 죽, INSERT가 여러 번 일어남(주문 테이블 -> 주문상품 테이블)
- 에러가 났다..?
  - **트랜잭션 기능이 없으면 INSERT된 기존 데이터를 DELETE로 지워야해**



### 2. 롤백과 커밋

**롤백 -> SQL 실행 전으로 되돌린다(아무 변화 X)**

**커밋 -> 아무 에러 X, 변경사항을 적용하고 트랜잭션을 종료한다**

조건 : 오토커밋 모드 끄기

``` sql
START TRANSACTION;
INSERT INTO 주문 VALUES ...;
INSERT INTO 주문상품  VALUES ...;
INSERT INTO 주문상품  VALUES ...;
COMMIT;
```

#### 트랜잭션 처리 -> 간단하게 데이터 돤리



### 3. 트랜잭션 사용법

**세트로 실행하고싶은 SQL 명령 -> 트랜잭션 내에서 실행**
