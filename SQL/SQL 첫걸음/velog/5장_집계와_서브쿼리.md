## 20강_행 개수 구하기 - COUNT

``` mysql
-- 집계함수
COUNT(집합)
SUM(집합)
AVG(집합)
MIN(집합)
MAX(집합)
```

SQL은 **데이터 집합**을 다루는 언어



### 1. COUNT로 행 개수 구하기

집계함수는 **집합을 인수**로 지정

행 개수를 구할 떄 쓴다.

**\- WHERE구 지정** -> 조건에 맞는 행의 개수 구할 수 있다.

**결과는 하나의 행**



### 2. 집계함수와 NULL값

**집계함수는 집합 안에 NULL 값이 있을 경우 무시**



### 3. DISTINCT로 중복 제거

DISTINCT는 예약어



### 4. 집계함수에서 DISTINCT

특정 열에서 NULL값 제외시키고 DISTINCT 적용하려면?

**COUNT(DISTINCT name)**



## 21강_COUNT 이외의 집계함수

### 1. SUM으로 합계 구하기

집계함수 -> 쉽게 구할 수 있음(반복문 X)

**NULL값을 제거한 뒤 합계를 냄**



### 2. AVG로 평균내기

NULL값 제거한 뒤 평균을 냄

만약 NULL을 0으로 한 후 평균? -> CASE 문으로 변경

SELECT AVG(CASE .. WHEN .. THEN .. END)



### 3. MIN, MAX로 최솟값, 최댓값 구하기

문자열형, 날짜시간형에도 사용할 수 있음

NULL값 무시!!!



## 22강_그룹화 - GROUP BY 

``` mysql
-- SYNTAX
SELECT * FROOM 테이블명 GROUP BY 열1, 열2, ...
```

집계함수로 넘겨질 집합을 **그룹으로** 나누기!



### 1. GROUP BY로 그룹화

**지정된 열의 값이 같은 값들을 하나의 그룹으로 묶음**

그룹화 -> 집계함수 사용하는게 아니면 크게 의미가 없다

**엄청 자주 쓰임**



### 2. HAVING 구로 조건 지정

MYSQL 내부처리

- WHERE구 -> GROUP BY 구 -> HAVING 구 -> SELECT 구 -> ORDER BY 구

**WHERE구에서는 집계함수 쓸 수 없음**

HAVING 구 다음 조건식이 참인 집합들의 집계함수만 결과에 반환

**집계함수를 사용할 경우 HAVING구로 검색조건 지정**



### 3. 복수 열의 그룹화

GROUP BY -> **집계 함수를 사용하지 않은 채 SELECT 구에 넣으면 안 돼**



### 4. 결괏값 정렬

**집계 함수의 결과를 -> ORDER BY로 정렬 가능**





## 23강_서브쿼리*****************************

``` sql
-- SYNTAX
(SELECT 명령)
```

어디서든 사용 가능



### 1. DELETE의 WHERE구에서 서브쿼리 사용하기

``` sql
DELETE FROM CAR WHERE cost = (SELECT MIN(cost) FROM CAR) as x;
```

mysql에서 사용하려면

``` sql
DELETE FROM CAR
WHERE cost = 
	(SELECT a FROM 
   		(
  		SELECT MIN(cost) AS a FROM CAR
    	)
  );
```

**인라인 뷰로 임시 테이블을 만들어야 함**



#### cf) 변수 사용

``` sql
SET @c = (SELECT MIN(cost) FROM CAR);
DELETE FROM CAR WHERE cost = @c;
```



### 2. 스칼라 값

**SELECT 명령이 하나의 값만 반환 => 스칼라 값 반환!**

#### = 연산자 -> 스칼라 값 끼리 비교!



### 3. SELECT 구에서 서브쿼리 사용하기

**스칼라 서브쿼리!**

#### cf) dual 테이블 -> DB에 기본으로 작성되는 테이블, 그냥 확인할 떄 사용

``` sql
SELECT 
	(SELECT COUNT(*) FROM table1) AS sq1,
	(SELECT COUNT(*) FROM table2) AS sq2 FROM DUAL;
```



### 4. SET 구에서 서브쿼리 사용

하나의 값(스칼라 값)만 반환하는 서브쿼리 -> 사용 가능

### 5. FROM 구에서 서브쿼리 사용

**모든 서브쿼리가 다 올 수 있다!!**

``` sql
SELECT * FROM (SELECT * FROM car) c;
```

- NESTED SUBQUERY라고 함.
- 중첩 서브쿼리



ORACLE의 경우에는 LIMIT 구가 없기에, 중첩 서브쿼리를 사용

즉, 특정 열로 내림차순 -> 이를 중첩 서브쿼리로 -> ROWNUM 활용해서 추출



### 6. INSERT 명령에서 서브쿼리

1. VALUES 구 값으로 서브쿼리 사용 가능

2. INSERT SELECT도 가능

   - INSERT INTO car SELECT 1,2;

   - 괄호를 붙이지 않아 서브쿼리라고 불리기 애매

   - 테이블 복사할 때 사용

   - ``` sql
     INSERT INTO sample SELECT * FROM sample2
     ```

   - 물론 열과 열 타입은 같아야겠죠?



## 24강_상관 서브쿼리

``` sql
-- SYNTAX
EXISTS (SELECT 명령)
```

EXISTS 술어와 함께 쓰임

### 1. EXISTS

``` sql
-- no1-sample1의 열, no2-sample2의 열
UPDATE sample1 SET a = '있음'
WHERE EXISTS(
	SELECT * FROM sample2
	WHERE no2 = no1);
```

EXISTS 연산자 -> subquery가 하나 이상의 행을 반환하면 **true**

서로 다른 2개의 테이블을 비교할 때 

조금 더 쉽게

``` sql
SELECT *
FROM customers c
WHERE EXISTS (
  SELECT 1 FROM orders WHERE c.customer_id = orders.customer_id);
```

한 번이라도 주문한 고객의 정보를 모두 출력

이처럼 다른 테이블에서 하나씩 비교하기 힘들 때 사용한다



### 2. NOT EXISTS

``` sql
UPDATE sample1 SET a = '없음'
WHERE NOT EXISTS(
	SELECT * FROM sample2
	WHERE no2 = no1);
```

a 열이 있음, 없음으로 모두 채워짐



### 3. 상관 서브쿼리

부모, 자식, 즉 비교하려는 두 대상끼리 관련이 있는 조건식이 있을 때

**만약 서브 쿼리가 단독으로 실행되면 상관 서브쿼리가 아니다!**



열 명이 같은 경우 -> 어느 테이블에서 왔는지 **테이블.열명** 으로 나타내면 해결

**!!!!!!!!!! 테이블명.열명(car.cost) , 테이블명 항상 붙이자 !!!!!!!!!!**



### 4. IN

집합 끼리 비교, 스칼라 값 끼리는 (= 연산자)

``` sql
-- SYNTAX
열명 IN (집합)

-- EX : sample2.no2의 값이랑 sample1.no의 값이 일치하는 경우만 반환
SELECT * 
FROM sample1
WHERE no IN (
	SELECT no2 FROM sample2
);
```



#### cf) IN과  NULL

- 집계함수와 다르게 NULL값 무시 안함
- 다만 NULL = NULL 연산 불가능이니, NULL값은 비교 못 함

**그냥 NULL 값은 IS NULL, IS NOT NULL 로만 비교하자!!!** 