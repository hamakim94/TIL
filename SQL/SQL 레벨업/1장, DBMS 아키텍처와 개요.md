## 1강_DBMS 아키텍처 개요

SQL 구문 -> (쿼리 평가 엔진) -> 접근 메서드 -> 버퍼 매니저 -> 디스크 용량 매니저

​                                                 (소통 : 트랜잭션 매니저 , 락 매니저, 리커버리 매니저)

1. 쿼리 평가 엔진
   - SQL 구문 분석 -> 어떻게 데이터에 접근 할지 정함

2. 버퍼 매니저
   - 특별한 용도로 사용하는 메모리 영역(관리)

3. 디스크 용량 매니저
   - DB는 데이터를 영구적으로 저장. 어디에 어떻게 저장 + I/O 관리

4. 트랜잭션 매니저와 락 매니저
   - 여러명 동시 접근 -> 트랜잭션 단위
   - 정합성 유지, 필요한 경우 데이터 락(다른사람 요청 대기)

5. 리커버리 매니저
   - 언제나 장애 발생 가능
   - 정기적 백업 + 문제 일어났을 때 복구



## 2강_DBMS와 버퍼

1. 공짜 밥은 존재할까?
   - 1차 기억장치, 2차(HDD) 기억장치, 3차 기억장치(테이프) 종류 (빠른데 비쌈,  느리지만 쌈)
   - **기억 비용** 을 늘 생각하자



2. DMBS와 기억장치의 관계
   - HDD (DB 대부분)
   - 메모리(비쌈)
   - 버퍼를 활용한 속도 향상
     - 메모리 사용 이유(1차 기억장치), 바로 접근해서 결과 반환



3. 메모리 위에 있는 두 개의 버퍼
   - **데이터 캐시(SELECT)**
     - 자주 접근하는 데이터 올려놓기
   - **로그 버퍼(INSERT, DELETE, UPDATE, MERGE등)**
     - 갱신 처리는 비동기! ( 성능 높이기 위해선 비동기가 빠름 )



4. 메모리의 성질이 초래하는 트레이드오프
   - 메모리 : **휘발성**
   - 장애가 발생하면, 메모리에 있던 데이터 전부 삭제 -> 데이터 부정합
     - 데이터 캐시는 ㄱㅊ, 그냥 저장장치 접근하면 돼
     - 로그 버퍼는?
       - 로그 파일에 반영되기 전 장애 발생하면..?
       - 갱신 정보 사라짐
       - 따라서 DBMS는 커밋 시점에 갱신 정보를 로그 파일에 써서 영속화함(디스크 동기 접근)
   - 동기 접근, 비동기 접근에 trade-off를 잘 생각하자



5. 시스템 특성에 따른 트레이드오프
   - 데이터 캐시는 큰데, 로그 버퍼는 작아
   - 일반적으로 **조회** 에 초점을 맞췄기 때문
   - 내가 하는 서비스가 조회 말고 갱신이 많다면 로그 버퍼를 크게!



6. 추가적인 메모리 영역 '워킹 메모리'
   - 정렬(ORDER BY), 집합 연산, 윈도우 연산, 해시~
   - 워킹 메모리도 부족하면 저장소를 사용
   - 다만 여기서 저장소 사용하면, 에러를 내는게 아니라 다른걸 락을 걸어서라도 모든 요청을 끝낸다는 DBMS의 특징이 있다.



## 3강_DBMS와 실행 계획



1. 권한 이양의 죄악
   - How에 대한 작성을 안 해 -> 어떻게 접근하는지 몰라서 생기는 문제 많음



2. 데이터에 접근하는 방법은 어떻게 결정할까?
   - 쿼리 평가 엔진이 파싱 -> 옵티마이저 -> **카탈로그 매니저(통계 정보)** -> 플랜 평가 -> 최적 결과 실행



3. 옵티마이저와 통계 정보

   - 통계 정보(각 테이블 레코드 수, 필드 수, 필드 크기, 카디널리티, 히스토그램. NULL 수, 인덱스 정보)

   - 갱신 시 바로 정보 갱신 X -> 옵티마이저가 이상한걸 보고 할 수 있음
   - 그런데 카탈로그 매니저가 관리하는 통계 정보를 갱신하는 것은 비용이 크다!



4. 최적의 실행 계획이 작성되게 하려면
   - 우리가 공부해서 정해야 한다~



## 4강_실행 계획이 SQL 구문의 성능을 결정

1. 실행 계획 확인 방법
   - 명령어를 통해서 함



2. 테이블 풀 스캔의 실행 계획
   1. **조작 대상 객체**
   2. **객체에 대한 조작의 종류(알고리즘)**
   3. **조작 대상이 되는 레코드 수**
      - 위 3개는 필수
      - cf) 다 추정이기 떄문에 맹신은 no



3. 인덱스 스캔의 실행 계획
   - N -> logN (빠르다)
   - Sequential Search -> Index(B-tree)
4. 간단한 테이블 결합의 실행 계획(join)
   - Nested Loop(for문 2개)
   - Sort Merge(전처리 정렬 -> 워킹 메모리 사용) 
   - Hash(working memory 필)

## 5강, 실행 계획의 중요성

옵티마이저가 제대로 못 할 수도 있음

- 옵티마이저에게 강제로 명령할 수 있는 방법이 있다(우리가 공부하는 이유)