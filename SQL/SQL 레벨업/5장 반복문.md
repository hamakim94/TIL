절차 지향형의 속박

- **집합 지향**적인 사고로 문제를 해결해야 하는데, 적용이 생각보다 어려우



## 14강_반복문 의존증

- 내부적으로는 반복문을 사용하긴 함.
- 앞으로 반복문 직접 구현(반복계)
- SQL 자체 사용(포장계)



## 15강_반복계의 공포(vs 포장계)

이전 년도 대비 +, -를 단순 반복문(LOOP)으로 구현하려면

- 커서, 레코드 타입, 카운터
- 레코드를 패치해서 변수에 대입
- 레코드가 없다면 반복을 종료
  - 조건 비교
- 등록 대상이 테이블에 테이블을 등록
  - **한 번에 한 레코드**

### 1. 반복계의 단점

- 성능

#### - SQL 실행의 오버헤드

SQL 실행

​	  전처리

1. SQL 구문을 네트워크로 전송

2. DB 연결

3. **SQL 구문 파스**

4. **SQL 구문의 실행 계획 생성 또는 평가** => 오래 걸림

   후처리

5. 결과 집합을 네트워크로 전송



파스가 문제인데, 작은 SQL 여러 번 반복 -> 오버헤드 높아짐

#### - 병렬 분산이 힘들다

#### - DB 진화로 인한 혜택을 바을 수 없다.

대부분 포장계로! 따라서 **튜닝할 수 없음**



### 2. 반복계를 빠르게 만드는 방법?

#### 반복계를 포장계로 다시 작성(BAD)

#### 각각의 SQL을 빠르게 수정(BAD)

#### 다중화 처리(그나마)

- 물리적으로 해결



### 3. 반복계의 장점

사실 반복계의 SQL 구문은 지나치게 단순한 편

#### 실행 계획의 안전성

- 변동 위험이 X

#### 예상 처리 시간으 정밀도

- 한 번의 처리 시간 X 실행 횟수
- 정확하게 계산 가능

#### 트랜잭션 제어가 편리



## 16강. SQL에서는 반복을 어떻게 표현할 까?

### 1. CASE 식, 윈도우 함수

- ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING 
  - 레코드 직전의 1개로 제한

``` sql
# 직전 회사명과 직전 매상
SELECT company, year, sale,
	MAX(company) OVER( PARTITION BY company
                    ORDER BY year
                    ROWS BETWEEN 1 PRECEDING 
                    AND 1 PRECEDING)
                AS pre_company,
	MAX(sale) OVER( PARTITION BY company
                    ORDER BY year
                    ROWS BETWEEN 1 PRECEDING 
                    AND 1 PRECEDING)
                AS pre_sale,
FROM Sales;          
```

cf) 상관 서브쿼리

- 서브쿼리 내부에서 외부 쿼리와의 결합 조건 사용~

### 2. 최대 반복 횟수가 정해진 경우

우편번호 비슷한거 찾기(앞 자리수 부터 같으면, 지역이 많이 가까움! )

CASE로 다 똑같으면 0, 맨 뒤만 다르면 1, 이런식으로.. RANK 필드를 만든다

**순위가 가장 높은 우편번호를 선택**

- MIN 함수로 구한다

#### 윈도우 함수 사용 -> 스캔 횟수 감소

- 순위의 최솟값을 서브 쿼리에서 찾으면, 2번 테이블 탐색
  - 한 번으로 줄이고 싶을 때
- 근데 윈도우 함수 -> 정렬..!



### 3. 반복 횟수가 정해지지 않는 경우

#### 인접 리스트 모델과 재귀 쿼리

'인접 리스트 모델'

- 특정 필드의 끝 -> 특정 필드의 시작점을 연결
- 포인터 체인

WITH RECURSIVE -> 재귀적으로 상한 탐색

- 최근에 만들어짐, 대체 수단



#### 중첩 집합 모델

SQL 계층 구조

1. 인접 리스트 모델
2. 중첩 집합 모델
3. 경로 열거 모델

2번이 짱

- 0~27 사이가 맥스고 (3등분한다)
  - 다음 계층은 9~18
    - 다음 계층은 12 ~ 15

가장 부모 찾기

``` sql
SELECT name, pcode
 FROM xx 
WHERE NAME = 'A'
	AND NOT EXISTS
		(SELECT *
    	FROM xx2
    	WHERE xx2.name = 'A'
    	AND xx.lft > xx2.lft)
```



## 17강 바이어스의 공죄

반복 -> 절차로!

