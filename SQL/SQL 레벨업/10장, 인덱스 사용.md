## 들어가기 전에

균형의 약점

- 가장 일반적이면서 중요한 인덱스 방법은 B-tree
- 가장 일반적으로 널리 쓰이는 튜닝 수단



## 34강, 인덱스와 B-tree

3가지

### 1. 만능형 : B-tree

B+tree : 리프 노드에만 키 값을 저장

특징

- 루트와 리프의 거리를 가능한 일정하게 유지하려 함
- 트리의 깊이도 3~4개 정도 수준으로 일정하고, 데이터가 정렬되어 있음

### 2. 기타 인덱스

- 비트맵
  - 비트 플래그로 변환, 카디널리티가 낮은 필드에 효과
  - 갱신할 떄 오버헤드가 너무 큼
- 해시 인덱스
  - 키를 분산 -> 등가 검색을 고속으로 실행
  - 사용 X



## 35강_인덱스를 잘 활용하려면

### 1. 필드의 카니널리티와 선택률

- 카디널리티 : 값의 균형
  - 가장 높은 필드 -> 모든 ㄹ코드에 다른 값이 들어가있는 유일 키 필드
- 선택률 : 특정 필드값 지정 -> 테이블 전체에서 몇 개의 레코드가 선택되는지
  - 100개의 레코드, pkey = 1, 1/100, 선택률 1%

- cf) 클러스터링 팩터
  - 저장소에 같은 값이 물리적으로 뭉쳐 존재하는지
  - 높을수록 분산, 낮을수록 뭉쳐있음
  - 백터가 낮을수록 접근할 데이터 양이 적어짐
  - DBMS별 인덱스 필드에 있는 경우도 있음

### 2. 인덱스를 사용하는 것이 좋은지 판단하라면

- 카디널리티가 높을수록 
  - 값이 평균지에서 많이 흩어져있을수록
- 선택률이 낮을 것
  - 한 번에 선택으로 레코드가 조금만 선택되는 곳 (5 ~ 10 %)
  - 5% 미만이면 필드 집합은 인덱스를 작성할 가치가 있을 수 있다
  - 10%보다 높으면 테이블 풀 스ㅐ캔이 더 빠를 수 있음

## 36강_인덱스로 성능 향상이 어려운 경우

### 1. 압축 조건 존재 X

필터링 자체가 X, 그냥 full로 가져오는 sql문

### 2. 레코드를 제대로 압축하지 못하는 경우

```sql
SELECT order_id, receive_date
FROM Orders
WHERE process_flg = '5';
```

- 상황

  - | 상태 | 개수        |
    | ---- | ----------- |
    | 1    | 200만 건    |
    | 2    | 500만 건    |
    | 3    | 500만 건    |
    | 4    | 500만 건    |
    | 5    | 8,300 만 건 |

- process_flg = 5 써도, 레코드 절반 이상이 선택
  - 인덱스를 만들어도, 선택률이 83%, 역효과

#### - 입력 매개변수에 따라 선택률이 변동하는 경우

``` sql
SELECT order_id
FROM Orders
WHERE receove_date BETWEEN :start_date AND :end_date;
```

- 이러면 기간에 따라 선택률이 달라질 듯

#### - 입력 매개변수에 따라 선택률이 변동하는 경우 2

```sql
SELECT COUNT(*)
FROM Orderss
WHERE shop_id = :sid;
```

- 큰 점포일수록 주문이 많음
  - 선택률이 천차말변

### 3. 인덱스를 사용하지 않는 검색 조건

압축할 조건이 있어도 인덱스를 사용할 수 없음 떄

#### - 중간 일치, 후방 일치의 LIKE 연산자

``` sql
SELECT order_id
FROM Orders
WHERE shop_name like '%대공원%';
```

shop_name 필드에 인덱스를 지정하면?

- 전방 검색에만 적용할 수 있음



몇 가지 상황

#### - 색인 필드로 연산하는 경우

``` sql
SELECT *
FROM SomeTable
WHERE col_1 * 1.1 > 100;
# 옳은 방향
WHERE col_1 > 100/1.1;
```

- 하지만 검색 조건에 우변에 식을 사용할 때는 인덱스 사용

#### - IS NULL 사용하는 경우

#### - 색인 필드에 함수를 사용할 떄

#### - 부정형을 사용할 때 ( <>, != , NOT IN)



## 37강_인덱스를 사용할 수 없는 경우 대처법



### 1. 외부 설정으로 처리 - 깊고 어두운 강 건너기

#### - UI 설계로 처리

 UI 자체를 선택률 높게는 못하게 

### 2. 외부 설정을 사용한 대처 방법의 주의점

시스템 사용자 : **아무런 필수조건 없이 내 마음대로 입력**하는걸 좋아함

앱 개발자 - DB 개발자 소통 잘 안 되면 망함

### 3. 데이터 마트로 대처

개요 태이블(summary table)

- 접근 대상 테이블의 크기를 작게 해서 I/O 양을 줄이는 것

### 4. 데이터 마트의 주의점

4가지

#### - 데이터 신선도

원래 테이블의 부분적인 복사본

#### - 데이터 마트 크기

크기를 딱히 줄일 수 없으면 필요 X

- **GROUP BY를 미리 사용해서 집계를 마치고 데이터 만들면 효과적*

#### - 데이터 마트 수

ER에도 등장하지 않는 부수적인 것

관리가 어렵고, 저장소용량 압박, 백업 또는 스냅샷 할 때의 시간이 오래걸림

지나친 의존은 XX

#### - 배치 윈도우

만들어진 데이터 마트는 어느 정도 규모의 갱신이 발생할 때 통계 정보도 다시 수집



### 5. 인덱스 온리 스캔으로 대처

``` sql
SELECT order_id, receive_date
FROM Orders;
```

테이블 풀 스캔인데,, 이를 인덱스로?

``` sql
CREATE INDX CoveringIndex ON Orders(oder_id, receive_date)
```

2개의 필드를 커버하는 인데스 존재! -> **테이블 접근 생략**



#### cf) 컬럼 지향 DB vs 로우 지향 DB

로우 지향 - 대부분 RDB 

- 하나의 필드 값만 필요해도, 행 전체 데이터를 우선 읽고 선별해서 가져온다

컬럼 지향 DB

- 인덱스 온리 스캔 느낌! 
- 그러나 where 조건 -> 결국 해당 필드 모두 스캔

### 6. 인덱스 온리 스캔의 주의사항

#### - DBMS에 따라 사용할 수 없는 경우도 있다

#### - 한 개의 인덱스에 포함할 수 있는 필드 수에 제한이 있다.

- 매뉴얼 잘 살펴봐야.

#### - 갱신 오버 헤드가 커진다

갱신 성능이 많이 떨어진다!! (대신 검색 속도와의 trade-off)

#### - 정기적인 인덱스 리빌드가 필요

크기에 매우 민감

정기적인 크기 모니터링 -> 리빌딩을 운용에 포함시켜야 함



#### - SQL 구문에 새로운 필드가 추가된다면 사용할 수 없다.

select 정돈, 필드 추가해도 OKOK!(개발자)

**인덱스 온리 스캔 -> 꼭 알아두어야 함!!!!**



