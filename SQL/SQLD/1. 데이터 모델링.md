# 1. 데이터 모델링



## 데이터 모델링 유의할 점

1. 중복
2. 비유연성(inflexibility)
3. 비일관성(inconsitency)
   - 일관성 in DB
     - 트랜잭션이 데이터 무결성에 대한 제약 조건과 호환돠어야 함
4. 비정규화는 고려하지 않는다.



#### 무결성?

- 완전한 수명 주기를 걸치며
- 데이터의 정확성과 일관성을 유지하고 보증하는 것



## 데이터베이스 스키마 구조 3단계

##### 스키마?

- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세
  - 개체의 특성(**속성, Attribute**)
  - 속성들의 집합으로 이루어진 **개체(Entity)**
  - 개체 사이에 존재하는 **관계(Relation)**
  - 유지할 **제약 조건**
- DB내에 어떤 구조로 데이터가 저장되는가!



##### 외부 스키마

- 서브 스키마, 사용자 뷰
- 실세계에 존재하는 데이터들을 어떤 형식, 구조, 배치 화면을 통해 사용자에게 보여줄까
- 사용자나 응용 프로그래머가 개인의 입장에서 필요한 DB의 논리적 구조를 정의

##### 개념 스키마

- 통합 관점의 스키마 구조 표현
- DB 전체, 하나

##### 내부 스키마

- 물리적인 저장장치 입장에서 DB가 저장되는 방법 기술



## 기본 엔터티 vs 중심 엔터티

### 기본 엔터티(키엔터티)

- 업무에 원래 존재하는 정보
- 다른 엔터티와의 관계에 의해 생성되지 않고 독립적으로 생성이 가능
- 자신은 타 엔터티의 부모의 역할을 하게 된다
- 다른 엔터티리로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지게 된다

#### 중심 엔터티

- 기본 엔터티로부터 발생하고, 그 업무에 있어서 중심적인 역할
- 데이터의 양이 많음

#### 행위 엔터티

- 두 개 이상의 부모엔터티로터 발생, 자주 내용이 바뀌거나 데이터양 증가
- 분석 초기 단계에서는 잘 나타나지 않으며,상세 설계단계나 프로세스의 상관모델시 도출



## 속성(Attribute)

### 정의

- **업무에서 필요로 하는 인스턴스에서 관리하고자 하는, 의미상 더 이상 분리되지 않는 최소의 데이터 단위**

### 관계

- 한 개의 엔티티 -> 두 개 이상의 인스턴스의 집합
- 한 개의 엔티티 -> 두 개 이상의 속성을 갖는다
- 한 개의 속성 -> 한 개의 속성값!

### 특성에 따른 분류

- 기본 속성
  - 업무에 필요한 거
- 설계 속성 : 원래 필요하지는 않지만 필요에 따라 설계자가 추가한 속성, 
  - **코드 속성, 일련번호 -> 식별자 역할**
- 파생 속성(Derived Attribute)
  - 데이터를 조회할 때 빠른 성능을 할 수 있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성
  - **그냥 매번 값이 변하는 것, 주문 -> 주문 금액(주문을 얼마나 했는지에 따라 변하고), 최초 주문 일자 -> 언제 주문했는지에 따라 변하고. 등등**
  - **이자율은 파생속성이 아니다!**



## 도메인

### 정의

- 각 속성(Attribute)이 가질 수 있는 값의 범위
- 엔터티 내에서 속성에 대한 데이터타입과 크기, 그리고 제약 사항 지ㅈ정



## 식별자(키)

### 종류

- 주식별자 / 보조식별자

  - 엔티티 내에서 대표성을 가지는가!

- 내부식별자 / 외부식별자

  - 앤티티 내에서 스스로 생성되었는가!

- 단일식별자 / 복합식별자

  - 단일 속성으로 식별이 되는가!

- 본질식별자 / 인조식별자

  - 원래 의미가 있던 식별자 속성을 대체해 일련번호와 같이 새롭게 만든 식별자인가!

  

### 주식별자의 특징

- 유일성
  - 주식별자에 의해 엔터티내에 모든 인스턴스들을 유일하게 구분함
- 최소성
  - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 해!
- 불변성
  - 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야
- 존재성
  - 주식별자가 지정되면 반드시 데이터 값이 존재(NOT NULL)



### 식별자와 비식별자관계 비교



| 항목               | 식별자관계                                                   | 비식별자관계                                                 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 목적               | 강한 연결관계 표현                                           | 약한 연결관계 표현                                           |
| 자식 주식별자 영향 | 자식 주식별자의 구성에 포함됨                                | 자식 일반 속성에 포함됨                                      |
| 표기법             | 실선 표현                                                    | 점선 표현                                                    |
| 연결 고려사항      | - 반드시 부모엔터티 종속<br />- 자식 주식별자구성에 부모 주식별자포함 필요<br />- 상속받은 주식별자속성을 타엔터티에 이전 필요 | - 약한 종속관계<br />- 자식 일반 속성에 포함됨<br />- 자식 주식별자구성에 부모 주식별자 부분 필요<br />상속받은 주식별자속성을 타 언터티에 자단 필요<br />- 부모쪽의 관계참여가 선택관계 |







### 인스턴스는 DB에 저장된 데이터 내용의 전체 집합(행)

ERD - 동그라미는 필수 아님

## 부모 - 자식인데 주식별자 사용 X -> 따로 놀 때!, 즉 생명 주기도 달라야 함















# 2. 데이터 모델과 성능

## 성능데이터모델링?

- 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영

## 데이터 모델링 VS 성능 데이터 모델링(반정규화 들어감)

### 성능 데이터 모델링 절차

- 데이터모델링. 정규화 정확히 수행
- DB 용량산정
- 트랜잭션 유행 파악
- 용량과 트랜잭션 유헝에 따라 **반정규화** 수행
- 이력모델 조정, PK/FK 조정, 슈퍼/서브타입 조정
- 성능관점에서 데이터 모델 검증



정규화 수행 후 용량산정, 트랜잭션 우형 파악 -> 반정규화. PK/FK 조정 인텍스 특징 반영 데이터 모델 만들고 검증

## 동일한 유형의 속성이 칼럼단위로 반복 -> 제1정규화 대상이 됨(동일한 유형값을 가져도 1 정규화 대상) -> 1:M으로

 

## 반정규화!!

- 다량 데이터 탐색의 경우 인덱스가 아닌 방법도 있음(파티션, 데이터 클러스터링 등)
  - 이와 같이 다양한 물리 저장 기법을 활용해 성능 개선 유도 가능
  - 다만, 하나의 결과셋을 추출하기 위해 다량의 데이터 탐색하는 처리가 빈번하게 발생한다면 이때는 반정규화를 고려하자
- 문제 똑바로 읽기

### 반정규화 적용 대상

- 테이블, 속성, 관계
- 최대한 효율을 따져야 함. 관계 잘 생각



## 칼럼수가 많은 테이블 -> 잘 쓰는거, 안 쓰는거 1:1 분리



## 파티셔닝

- 하나의 테이블에 많은 양의 데이터 저장 -> 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있음
- 논리적으로는 하나의 테이블이지만, 물리적으로는 여러 개의 테이블로 분리하여 데이터 액세스 성능향상시키고, 데이터 관리방법도 개선할 수 있도록 테이블에 적용하는 기법
- Primary Key 성격에 따라 부분적인 테이블로 쪼개기



## 테이블 통합만 하면 안 돼, 각 사건 구분할 수 있도록 구분자 추가(보기 다 읽기)



## 트랜잭션은 항상 전체를 통합하여 분석 처리, 슈퍼-서브 타입이 하나의 테이블로 통합되어 하나의 테이블에 집적된 데이터만 읽어 처리할 수 있기 때문에 다른 형식에 비해 성능이 우수(조인 감소)



## 자식 테이블에도 업무상 연관이 많으면 인덱스!, FK제약조건은 눈가림, 인덱스 꼭 필요





### 논리적 데이터 모델링이 재사용성 제일 높음

제 2 정규화 : 부분 함수 종속이 제거된 상태 -> 기본키에 완전 함수 종속이 됨.



## GSI Global Single Instance : 통합된 한 개의 인스턴스 - 분산DB와는 대치
