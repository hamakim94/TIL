# 엔티티 매핑

- 정적인 측면(객체 - DB)



- 객체와 테이블 : @Entity, @Table
- 필드와 컬럼 : @Column
- 기본 키 : @Id
- 연관관계 매핑: @ManyToOne, @JoinColumn



## 객체와 테이블 매핑



### @Entity

- 해당 어노테이션이 붙은 클래스는 JPA가 관리, 엔티티라고 함
- JPA 사용 ? -> @Entity 필수
- 주의
  - **기본 생성자** 필수(파라미터 X, public or protected)
  - final 클래스, enum, interface, inner 클래스 사용 XX
  - (DB에) 저장할 필드에 final 사용 X

- @Table(name = "mbr")
  - DB에는 mbr 테이블이라는 이름으로 돼있을 때



## 데이터베이스 스키마 자동 생성

- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- 데이터베이스 방언을 활용해서 DB에 맞는 적절한 DDL 사용
- 이렇게 **생성된 DDL은 개발 장비**에서만 사용
- 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용



### hibernate.hbm2ddl.auto 옵션들

- in persistence.xml
  - create : 자동으로 테이블 만들어줌~
  - create-drop : 만들고 drop
  - update : 변경분만 반영(운영 DB에는 사용 X)
    - 새로운 컬럼 추가 -> Alter만 일어남!
  - validate : 엔티티와 테이블이 정상 매핑됐는지만 확인
    - 없는 필드 넣으면 에러~
  - none : 사용하지 않음(안 적는거랑 같음.)

**방언마다 다르다는걸 인식하자**



### 주의할 점

- **운영 장비 : create, create-drop, update 사용하면 절 대 안 돼**
- 개발 초기 : create 또는 update
- 테스트 서브는 update 또는 validate
- 스테이징과 운영 서버는  validate 또는 none
  - 데이터가 몇천만건 있는다면, alter를 자동으로 한다면, 너무 위험..!

- 5분동안 장애 등등..



create 옵션 : drop 하고 나서 create 하기 떄문에.. 정신 나가는 사태들 발생.!

alter -> 테이블 lock -> OH NO



### DDL 생성 기능

- 제약 조건 추가 : 회원 이름은 **필수**
  - @Column(nullable = false, length = 10)
- 유니크 제약조건 추가



DDL 생성기능은 DDL을 자동 생성할 때만 사용, JPA 실행 로직엔 영향 X

## 필드와 컬럼 매핑

### 요구사항 추가

1. 회원은 일반 회원과 관리자
2. 회원 가입일과 수정
3. 회원 설명 필드(길이 제한 X)



### 매핑 어노테이션

@Column , @Temporal(날짜), @Enumerated(enum 타입), @Lob(BLOB, CLOB), @Transient(컬럼 매핑 XX, 메모리에서만!)

- DB는 DATE, TIME, TIMESTAMP를 따로 관리하는 편
  - 그래서 Temporal annotation안에 옵션으로 어떻게 관리할지 매핑
- Lob 같은거 있는데, 이건 엄청 큰 데이터



### @Column properties :  가장 중요

- nullable(기본값 true) - not null 제약조건
- @Enumerated
  - 기본 : 2가지,
  - **주의 : default 인 ORDINAL 사용 X**
    - 요구사항 추가, ENUM 필드 하나 추가 -> 순서대로 반영 XX
    - **필수 : EnumType.STRING을 꼮 사용**

- @Temporal 옵션

  - LocalDateTime 쓰면 해결, Java 8 이상 사용하면 다 해결(최신 hibernate)

- @Lob옵션

  - 문자 : CLOB, 나머지는 BLOB

    



## 기본 키 매핑

### 기본 키 매핑 어노테이션

- @Id
  - 직접 할당(잘 사용 X)

- @GeneratedValue(strategy = ?? )
  - IDENTITY : DB에 위임, MYSQL
  - SEQUENCE : 데이터베이스  시퀸스 오브젝트 사용, ORACLE
    - @SequenceGenerator 필요
  - TABLE : 키 생성요 테이블 사용, 모든 DB에서 사용
    - @TableGenerator 필요
  - AUTO : 방언에 따라 자동 지정



### IDENTITY 전략

- 기본 키 생성을 DB에 위임
- 나는 모르겠고, DB야 알아서 해줘

#### 특징

DB에 값이 들어가는 시점에, ID값을 알고 있음

그런데, PK값을 알고 있어야지 영속성 컨텍스트로 관리할 수 있음..

위 전략만, em.persist 하는 시점에 insert가 들어감(그래야 PK값을 알 수 있음)



### SEQUENCE 전략

- 오라클
- **Long 무조건 쓰기!!**

#### 특징

DB에 값을 얻어와서(sequence) -> 그 값을 얻어와서 영속성 컨텍스트로~

커밋하는 시점에 insert query~

allocationSize : 50 => 미리 50개 사이즈를 땡겨놔~

- 여러 웹 서버가 있어도 동시성 이슈 없이 잘 실행되는 편!!!!
- 매번 DB 들어가서 sequence 확인 안 해도괜찮아!!!



### TABLE 전략

- 키 생성 전용 테이블 만ㄷ르어서 DB 시퀀스를 흉내
- 장점 : 모든 DB 다 적용 가능
- 단점 : 성능

#### 특징

이것도 allocationSize 가 있다!

### 권장하는 식별자 전략

- **기본 키 제약 조건** : null 아님, 유일, **변하면 안된다.**
- 미래까지 이 조건을 만족하는 자연키는 찾기 어려움, 대리키(대체키)를 사용하자
- ex) 주민등록번호도 기본키로 적잘하지 않다
- **권장 : Long형 + 대체키 + 키 생성전략**



PK를 주민번호를 쓰는 경우가 있음.. ( 정부 : 주민번호 들지 마)

- 이제 조인 하려면, foreignkey... 어머 주민번호 다 포함
- 난리가 났음



## 실전 예제 1 - 요구사항 분석과 기본 매핑

### 요구사항

회원은 상품 주문

주문 시 여러 상품~

### 도메인 모델

- 회원과 주문 : 회원은 여러번 주문할 수 있다(일대 다)
- 주문과 상품 : 주문할 때 여러 상품 선택 가능, 같은 상품도 여러개~



**엔티티 클래스에, DB 제약 조건 걸어두는 편(개발자가 보기 편함)**

인덱스도 넣음 + 컬럼 제약 조건! => JPQL 할 때



객체는 참조로 죽죽죽 탈 수 있어야 함

- 연관 관계 매핑을 이제 다음 섹션에서 배운다!!

