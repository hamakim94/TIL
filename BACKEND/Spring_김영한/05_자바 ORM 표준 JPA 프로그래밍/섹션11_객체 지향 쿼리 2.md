## 경로 표현식

- .(점)을 찍어 객체 그래프를 탐색하는 것

select **m.username** **-> 상태 필드**

​	from Member m

​		join **m.team** t -> **단일 값 연관 필드**

​		join **m.orders** o -> **컬렉션 값 연관 필드**

where t.name = '팀A'



### 용어 정리

- **상태 필드**(state filed) : 단순히 값을 저장하기 위한 필드
- **연관 필드**(association field) : 연관관계를 위한 필드
  - **단일 값 연관 필드**
    - @ManyToOne, @OneToOne, 대상이 엔티티
  - **컬렉션 값 연관 필드**
    - @OneToMany, @ManyToMany, 대상이 컬렉션



### 경로 표현식 특징

- 상태 필드(state field): 경로 탐색의 끝, 탐색 X
- 단일 값 연관 경로: 묵시저 내부 조인(inner join) 발생, 탐색 O
  - **실제 운영 시 매우 주의해야 함**
- 컬렉션 값 연관 경로: 묵시적 내부 조인 발생, 탐색 X
  - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

### 그냥 묵시적 조인 쓰지 말고, 다 SQL처럼 쓰렴

- 유지보수가 훨씬 쉬움

### 명시적 조인 -> join 직접 쓰는거!!



### 주의 사항(묵시)

- 항상 내부 조인
- 컬렉션은 경로 탐색의 끝, 명시적 조인을 통해 별칭 얻기
- 경로 탐색은 주로 select, where 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM 절에 영향을 준다



### 실무

- **가급적 묵시적 조인 대신 명시적 조인 사용**
- 조인은 SQL 튜닝에 매우 중요한 포인트!!!!!!!!!
- 묵시적 조인은 조인이 일어나는 상황을 한 눈에 파악하기 어려움



## 페치 조인 1 - 기본

### 실무에서 정말정말 중요함



### fetch join

- SQL 조인 종류X
- JPQL에서 **성능 최적화**를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 **SQL 한 번에 함께 조회**하는 기능
- join fetch 명령어 사용



### 엔티티 페치 조인

- 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번)

- SQL을 보면 회원 뿐만 아니라 **팀(T.*)도 함께 SELECT**

- Select m from member m **join fetch** m.team

- select M.\*, <a color="blue">T.*</a> from Member M 

  **INNER JOIN TEAM T** ON M.TEAM_ID = T.ID



```java
String query =  "select m from Member m";
List<Member> result = em.createQuery(query,Member.class).getResultList();
for (Member member : result) {
System.out.println("member = " + member.getUsername() + 				member.getTeam().getName());
```

멤버 1명 -> 팀 1명(ManyToOne -> fetch = LAZY) 

- 팀A로 우선 조인해서 DB에서 한 번 가져옴
- 회원 B까지 가능
- 회원 C -> DB 조인해서 한 번 가져옴 -> 반영(영속성 컨텍스트)

최악의 경우, 전체 member(N명) 가져옴 -> 해당 엔티티 -> N번 query

**N+1** 



=> 페치 조인밖에 없다

=> 이를 하면, on 절으로, 영속성 컨텍스트에 테이블이 다 들어가 있어서 매우 편해진다



### 컬렉션 페치 조인

- 일대다 관계, 컬렉션 페치 조인

[JPQL]

select t

from Team t **join fetch t.members**

Where t.name = '팀A'



일 대 다 조인 -> 데이터 뻥튀기



### 페지 조인과 DISTINCT ( 일 대 다 -> 뻥튀기 )

- SQL의 DISTINCT는 중복된 결과를 제거하는 명령
- JPQL의 DISTINCT 2가지 기능 제공
  1. SQL에 DISTICNT를 추가
  2. 애플리케이션에서 엔티티 중복 제거



select distinct t

from Team t **join fetch t.members**

Where t.name = '팀A'

 SQL에 DISTINCT를 추가하지만 데이터가 다르므로 SQL 결과에서 중복제거 실패



### 페치 조인 vs 일반 조인

- JPQL은 결과를 반환할 때 연관관계 고려 X

- 단지 SELECT 절에 지정한 엔티티만 조회할 뿐
- 여기서는 팀 엔티티만 조회, 회원 엔티틴 조회 X



- 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회**(즉시 로딩)**
- **페치 조인은 객체 그래프를 SQL 한 번에 조회하는 개념**



## 페치 조인 2 -> 한계

- **페치 조인 대상에는 별칭을 줄 수 없다.**
  - 하이버네이트에서는 가능, 가급적 사용 X
- **둘 이상의 컬렉션은 페치 조인 할 수 없다**
- **컬렉션을 패치 조인하면 페이징API(setFirstResult, seetMaxResults)를 사용할 수 없다**
  - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
  - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)
    - 데이터 다 끍어와서, 메모리에서 퍼올린다음에 페이징, 즉 터진다!!



N+1문제 -> 페치 조인 사용 , 근데 컬렉션 -> OneToMany에 batchsize 주기



### 페치 조인의 특징과 한계

- 연관된 엔티티들을 SQL 한 번으로 조회 -> 성능 최적화
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
  - @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 절량
- 실무에서 글로벌 로딩 전략은 모두 지연 로딩
- 최적화가 필요한 곳은 페치 조인 적용



### 정리

- 모든 것을 페치 조인으로 해결할 수는 없음
- 페치 조인은 객체 그래프르 ㄹ유지할 때 사용하면 효과적
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적



### 너무 중요, 100% 이해



## 다형성 쿼리

덜 중요, pt만

- 조회 대상을 특정 자식으로 한정
- Select i from Item i
- where type(i) IN (BOOK, MOVIE)



Treat

- 자바의 타입 캐스팅
- 상속 구조에서 부모 자십을 자식으로 타입 캐스팅
- select i from Item i
- where treat(i as Book).author = 'kim'



## JPQL - 엔티티 직접 사용

### 기본 키 값

- JPQL에서 엔티티를 직접 사용하면  SQL에서 해당 엔티티의 기본 키 값을 사용

JPQL

- Select **count(m.id)** from Member m // 엔티티 아이디 사용
- select **count(m)** from Member m // 엔티티 직접 사용

SQL

- SELECT COUNT(m.id) as cnt from Member m;



파라미터로 전달해도 -> 기본 키 값으로!



### 외래 키 값

m.team = :team

멤버가 팀에 대한 외래키 값을 들고 있음

```java
String query =  "select m from Member m where m.team = :team";
            List<Member> findMember = em.createQuery(query, Member.class)
                    .setParameter("team", teamA)
                    .getResultList();

            for (Member member : findMember) {
                System.out.println("member = " + member);
            }
```

```sql
/* select
        m 
    from
        Member m 
    where
        m.team = :team */ select
            member0_.MEMBER_ID as MEMBER_I1_0_,
            member0_.age as age2_0_,
            member0_.TEAM_ID as TEAM_ID5_0_,
            member0_.type as type3_0_,
            member0_.username as username4_0_ 
        from
            Member member0_ 
        where
            member0_.TEAM_ID=?
```



## JPQL - Named 쿼리



### Named 쿼리 - 정적 쿼리

- 미리 정의해서 이름을 부여해두고 사용하는 JPQL
- 정적 쿼리
- 어노테이션, XML에 정의
- 애플리케이션 로딩 시점에 초기화 후 재사용
  - 이미 SQL로 파싱 -> 캐싱 -> 엄청 빠름
- **애플리케이션 로딩 시점에 쿼리를 검증**



XML에 정의하는 방법도 있긴 함!

### 환경 설정

- XML이 항상 우선권
- 어플리케이션 환경에 따라 다른 XML을 배포할 수 있음~



결국 : 나중엔 SpringDataJpa -> 나중에  @Query -> NamedQuery로 샥샥





## 벌크 연산



### 벌크 연산

- 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?
- JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행
  1. 재고가 10개 미만인 상품을 리스트로 조회한다
  2. 상품 엔티티의 가격을 10% 증가한다
  3. 트랜잭션 커밋 시점에 변경감지가 동작한다
- 변경된 데이터가 100건이라면 100번의 UPDATE SQL 실행



### 예제

- 쿼리 한 번으로 여러 테이블 로우 변경(엔티티)
- **executeUpdate()의 결과는 영향받은 엔티티 수 반환**
- **UPDATE, DELEte 지원**
- **INSERT(insert into .. select, 하이버네이트 지원)**



### 주의점

- 벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리
- 문제점 해결 방법
  - 방법 1. 벌크 연산을 먼저 실행
  - **방법 2. 벌크 연산 수행 후 영속성 컨텍스트 초기화** -> em.clear()
    - find로 직접 가져와~



Flush() 영속성 컨텍스트 -> DB 반영, 잘못하면 데이터 저합성이 안 맞ㅇ므