# 섹션3\_영속성관리_내부동작방식



## 영속성 컨텍스트 1



### JPA 가장 중요



- 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping)
- **영속성 컨텍스트** 
  - 실제 JPA가 어떻게 동작해?



### 엔티티 매니저 팩토리 - 엔티티 매니저

- 매 요청마다 EntityManager 생성
  - 필요시 ConnectionPool에 있는 DB Connection을 사용



### 영속성 컨텍스트란?

- JPA를 이해하는데 가장 중요
- **엔티티를 영구 저장하는 환경**
- EntityManager.persist(entity)
  - 사실 DB에 저장하는게 아니라 객체를 영속성 컨텍스트라는 곳에 저장을 하는거



### 엔티티 메니저? 영속성 컨텍스트?

- 영속성 컨텍스트는 논리적인 개념
- 눈에 안 보임
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근



### 엔티티의 생명주기

- 비영속(new/transient)
  - 영속성 컨텍스트와 전혀 관계가 없는 **새로운** 상태
- 영속(managed)
  - 영속성 컨텍스트에 **관리**되는 상태
  - Persist 혹은 em.find() 한 상태
- 준영속(detached)
  - 영속성 컨텍스트에 저장되었다가 **분리**된 상태
- 삭제(removed)
  - **삭제**된 상태



### 비영속

- 그냥 엔티티 매니저에 아무것도 안 넣음
- 그냥 객체



### 영속

- ```java
  EntityManager em = emf.createEntityManager();
  em.getTransaction().begin();
  
  em.persist(member)
  ```

- 트랜잭션을 커밋하는 시점에 DB에 저장돼!



### cf) 준영속, 삭제

- detach하면 그냥 컨텍스트에서 분리
- remove - 실제 영구 저장하는 DB에서 지우겠다는 뜻!



### 영속성 컨텍스트의 이점

- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)



## 영속성 컨텍스트 2



### 엔티티 조회, 1차 캐시

- 영속성 컨텍스트 안에 1차 캐시가 있음.
- 1차 캐시를 영속 컨텍스트로 이해해도 무방하는 면이 있음
  - @Id, Entity가 들어가 있음 ( key - value 쌍 )
- DB보다 1차 캐시를 먼저 뒤져서, find method를 수행하는 편
- **만약 1차 캐시에 없으면?**
  - 이 때 DB에 저장, 1차 캐시에 없는 정보를 DB에서 반환
  - 영속성 컨텍스트(1차 캐시)에 저장
  - 없으면 XX
- 전체가 공유하는 cache - hibernate, jpa 안에선 2차 캐시라고 함



**사실 큰 성능 차이는 없지만, 객체지향적으로 짜는데 도움이 된다**



### 영속 엔티티의 동일성 보장

- == 하면 같다
- 1차 캐시를 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공



### 엔티티 등록

- 트랜잭션을 지원하는 **쓰기 지연**
- Commit 하는 순간 DB에 INSERT SQL을 보냄(예외는 있다)



#### persist 2번 하는 경우~

- 영속 컨텍스트 안에, 쓰기 지연 SQL 저장소라는 곳도 있다(1차 캐시 말고)
  - persist(memberA);
    - 1차 캐시에 일단 저장하고 동시에 INSERT SQL 생성
  - Persist(memberB);
    - 위와 마찬가지
- transaction.commit();
  - 쓰기 지연 SQL 저장소에 있던 에들이 flush
  - 이 떄 SQL에 저장이 된다
- 모았다가 한 번에 넣을 수 있는 버퍼링같은 개념이 있다!
  - 엄청난 이점, 이런 것들을 잘 활용하면 훨씬 빠를 수 있다!



### 엔티티 수정 : 변경 감지(dirty checking)

자바 컬렉션 다루듯이 그냥 set으로 이름만 바꿨는데. 알아서 update문 나감(persist 필요 XX)

COMMIT -> FLUSH()

- 엔팉와 스냅샷을 비교.(1차 캐시 안에는 사실 스냅샷 필드가 있음)
- 스냅샷 : 내가 딱 값을 읽어온 시점!

1. flush()
2. 앤티티와 스냅샷 비교
3. UPDATE SQL 생성
4. flush
5. commit



### 엔티티 삭제

remove - 방금 메커니즘이랑 똑같아(커밋 시점에)



## 플러시

- 영속성 컨텍스트의 변경내용을 DB에 반영



### 플러시 발생

- 변경 감지(dirty checking)
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 DB에 전종(등록, 수정, 삭제 ... )
  - 다 끝나고 commit이 일어나는 느낌



### 방법

- **em.flush()** - 직접 호출
- **트랜잭션 커밋** - 플러시 자동 호출
- **JPQL 쿼리 실행** - 플러시 자동 호출



cf) 1차 캐시가 지워지는게 아님, 영속성 컨텍스트에 있는 쓰기 지연 SQL 저장소, 변경 감지 -> 이런 것만!!!! DB에 반영



### JPQL - 플러시 자동 호출?

- 위에 있는 persist들이 반영이 안 되니까..
- 그럼 JPQL로 select 해오면, 위에 있는 컨텍스트들 XX
- 그래서 잘못하면 문제가 생기기 떄문에, flush 날리고 쿼리가 날라간다~



### 플러시 모드 옵션(사용 X)

- 만약 JPQL 쓰는데 다른 테이블에서 SELECT 해와야 할 때, flush 했을 떄 얻을 수 있는 이점 XX.. 근데 그냥 AUTO 써



### 플러시는!

- 영속성 컨텍스트를 비우는게 아님
- 영속성 컨텍스트의 변경내용을 DB에 동기화
- **트랜잭션이라는 작업 단위가 중요** -> 커밋 직전에만 동기화 하면 돼!



## 준영속 상태

- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리 ( detached )



### 방법

- em.detach(entity)
  - 특정 객체만!
- em.clear()
  - 통쨰로 다 지우기(초기화)
- Em.close()
  - 영속성 컨텍스트를 종료(잘 안 쓰임)







