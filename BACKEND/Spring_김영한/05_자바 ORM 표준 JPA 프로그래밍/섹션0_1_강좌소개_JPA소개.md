# 섹션 0



- 예전 : mybatis api를 활용해 sql 구문 직접 넣어야 했다



생각보다 실무에서 적용이 어려움(2가지)

- 올바르게 설계하지 못하면 큰일이 난다.
- 어떻게 정확히 동작하는지 모름..!
  - JPA가 어떤 SQL을 만들어 내는지
  - 언제 만드는지!





# 섹션 1

## SQL 중심적인 개발의 문제점

애플리케이션 - 객체지향

DB - RDBMS를 사용.



- 지금 시대는 객체를 관계형 DB에 관리
  - 근데, SQL..!!!



기존 : 무한 반복, 객체 CRUD.. 객체를 -> SQL, SQL -> 객체.. 

객체에 필드 하나 추가 -> 쿼리문 싹 다 고쳐야해..



### 패러다임의 불일치

- 객체 vs 관계형 DB
  - 객체지향 : **추상화, 캡슐화, 정보은닉, 상속, 다형성** 등 시스템의 복잡성을 해결할 수 있는걸 제공



#### 상속

- 객체 상속 -> Table 슈퍼타입 서브타입 관계(엇비슷함, 객체랑은 조금 다름)
  - 서브타입 -> 테이블, 필요시 조인으로 데이터를 가져와야함



#### 연관 관계

- 객체는 **참조**를 사용(getter 뭐시기 )
- 테이블은 **외래 키**를 사용(join)
  - sql에 따라, 탐색 범위가 달라진다..(객체랑 다름..!!)
  - 직접 DAO 에서 어떤 멤버를 가지고있는지 알아야 내가 원하는걸 할 수 있게 된다..
  - 상황에 따라 동일한 회원 조회 메서드를 여러벌 생성......

#### 계층형 아키택처 -> 진정한 의미의 계층 분할이 어렵다.



#### 비교하기

- == -> 다르잖아 ( 같은 id를 비교했을 때 같은 인스턴스가 아니라는 함정)

- 자바 컬렉션에서 하면 , 같음



#### 결국 객체답게 모델링을 할수록 매핑 작업만 늘어나는 상황이 많아짐......



### Q) 객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까?

- JPA - Java Persistence API



## JPA 소개

- 자바 진영의 **ORM** 기술 표준

### ORM?

- Object-Relational mapping ( R : RDBMS )
- 객체는 객체대로 설계
- 관계형 DB는 관계형 DB대로
- ORM 프레임워크가 중간에서 매핑
- 대중적인 언어에는 대부분 ORM 기술이 존재



### JPA는 애플리케이션과 JDBC 사이에서 동작함



### JPA 동작 - 저장

- JPA가 알아서 회원 객체 분석 -> INSERT하는 거 까지 알아서 다 함
- 패러다임 불일치 해결(java collection처럼 한 줄로 해결이 가능)

조회도 마찬 가지, id만 던지면 돼

**Entity Object를 딱 만들어서 반환해줌**



### 소개

EJB (Entity Bean - 자바 표준 ) - 하이버네이트(오픈 소스) - JPA(자바 표준)

### JPA는 표준 명세! 

- 인터페이스 모음
- 3가지 구현체 - 하이버네이트, EclipseLink, DataNucleus

 

### 성능 최적화

1. 1차 캐시와 동일성(identity) 보장
2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
   1. insert -> 트랜잭션 안에서 모아서 commit 할 시점에 뽱!
3. 지연 로딩(lazy loading)
   1. 객체가 실제 사용될 떄 로딩
   2. 즉시 로딩으로 하면 -> 다 가져옴~



### ORM은 객체와 RDB 두 기둥위에 있는 기술

- 결국 객체 지향 개념
- RDBMS 개념을 잘 알아야 함

