# 섹션5_연관관계 매핑 기초



### 목표

- **객체와 테이블 연관관계의 차이를 이해**
- **객체의 참조와 테이블의 외래 키를 매핑**
- 용어 이해
  - **방향**(Direction) : 단방향, 양방향
  - **다중성**(Multiplicity) : 다대일, 일대다, 일대일, 다대다
  - **연관관계의 주인**(Owner) : 객체 양방향 연관관계는 관리 필요 -> JPA 제일 어려운 부분



'객체지향 설계의 목표는, 자율적인 객체들의 **협력 공동체**를 만드는 것이다'

### 

### 예제 시나리오

- 회원과 팀이 있다
- 회원은 하나의 팀에만 소속될 수 있다
- 회원과 팀은 다대일 관계다

다: 해당 필드가 여러 값 중 하나가 될 수 있다는 느낌? -> 하나의 팀에 여러 명의 멤버가 들어갈 수 있다.



### 객체를 테이블에 맞추어 데이터 중심으로 모델링

- 협력 관계 X
- **테이블은 외래 키로 조인**을 사용해서 연관된 테이블을 찾는다.
- **객체는 참조**를 사용해서 연관된 객체를 찾는다
- 테이블과 객체 사이에는 이런 큰 간격이 있따





## 단방향 연관관계

내가 많은거, @ManyToOne

조인컬럼 설정



## 양방향 연관관계와 연관관계의 주인

- JPA의 포인터
  - 객체와 테이블의 패러다임 차이
  - 참조 vs 외래 키 조인
  - 이 차이를 잘 이해해야지.. 왜 필요한지 알아야 함



### 양방향 매핑

- 양쪽으로 참조값을 넣어두면 가능하긴 해!
- 테이블 : 방향이란 개념이 없음
  - 그냥 서로 조인하면 바로 얻을 수 있음
- 멤버 객체 안에서는, Team team이 있어 참조해서 바로 어떤 팀인지 알 수 있다
- **팀 객체 안에선, 어떤 멤버를 참조하고있는지 모르기 때문에, List<Members>가 필요함**
  - @MappedBy(어디서 참조하고 있는지, name = "team")
  - 나의 반대편 사이드에는 이게 걸려있어



### 연관관계의 주인과 mapped by

- mappedBy : JPA 멘탈붕괴 난이도
- mappedBy는 처음에는 이해하기 어렵다
- 객체와 테이블간에 연관관계를 맺는 차이를 이해해야 한다.

### 객체 vs 테이블 관계 차이

- 객체 연관관계 = 2개
  - 회원 -> 팀 연관관계(단방향)
  - 팀 -> 회원(단방향)
- 테이블 = 1개
  - 회원 <-> 팀의 연관관계(1개) (양방향) 
    - 이라곤 하지만, 그냥 외래 키 하나면 끝! 그냥 하난데 양쪽에서 쓸 수 있는 것

### 객체의 양방향 관계

- 객체의 **양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.**

- 객체를 양방향 참조 -> 단방향 연관관계 2개 만들어야 한다

  - A -> B (a.getB())

  - B -> A (b.getA())

  - ```java
    class A {
      B b;
    }
    class B {
      A a;
    }
    ```

### 테이블의 양방향 연관관계

- 테이블은 **외래 키 하나**로  두 테이블의 연관관계를 관리

- MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐(양족으로 조인할 수 있다.)- 

- ``` sql
  SELECT *
  FROM MEMBER M
  JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
  
  SELECT *
  FROM TEAM T
  JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
  ```



### 딜레마( 둘 중 하나로 외래 키를 관리해야 한다 )

멤버에 있는 팀을 바꿨을 때 Team의 값을 바꿔야 하는지

List<member> members의 값을 바꿨을 떄 Member 객체값이 바뀌어야 하는지..!



### 연관관계의 주인(Owner)

양방향 매핑 규칙

- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- **연관관계의 주인만이 외래 키를 관리(등록, 수정)**
- **주인이 아닌 쪽은 읽기만 가능**
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정



### 누구를 주인으로?

- **외래 키가 있는 곳**을 주인으로 정해라! 
  - 즉, 다!
    - N:1
    - @ManyToOne 연관관계의 주인!!!
- 여기서는 **Member.team**이 연관관계의 주인



그런데, 비즈니스적으로 중요한건 아님!

- 여기선, 자동차 - 자동차 바퀴
- 자동차 바퀴가 연관관계의 주인으로 JPA는 설정한다!



### 양방향 매핑시 가장 많이 하는 실수

- 연관관계 주인에 값을 입력하지 않음(커뮤니티에서도 참 많이 올라옴)
  -  mapped by , 즉 다대 일 상황에서 일 쪽에 데이터를 insert나 다른거 넣을 떄 안 들어감



#### 그러나, 순수한 객체 관계를 고려하면 양쪽다 값을 입력해야 한다.

- Em.flush, em.clear를 하지 않는 이상, DB에서 값을 가져오지 않고 1차 캐시에서만 쓰기 때문에 직접 넣어줘야 하는 부분이 매우 큼!(그래서 잘 씀)
- TestCase -> 안 맞는 경우 맞음



### 주의

- **순수 개게 상태를 고려해서 항상 양쪽에 값을 설정하자**
- **연관관계 편의 메소드**를 생성하자
  - setTeam에서, 자기 자신의 참조값을 넣어주는걸 해버리면 매우 편하게 쓸 수 있다.
  - 그러나 로직을 바꾼다, 그러면 set으로 쓰지 말고, changeTeam으로 하자!
  - 실수를 안 함
- 양방향 매핑시에 무한 루프를 조심하자
  - toString(), lombok, JSON 생성 라이브러리
  - Team -> members.toString -> team.toString -> ...... 다 만들어버려서 주이가 필요하다
  - 스택 오버플로우!!
  - 엔티티를 JSON으로 뽑을 떄도 문제가 생김, 즉 엔티티를 바로 반환해서 JSON으로 바꿀 때, .. 장애가 남
- 롬복 toString 쓰지 말고, 
- 컨트롤러에서 Entity 반환 하지 마 -> 엔티티는 DTO로 반환해라~



### 양방향 매핑 정리

- **단방향 매핑만으로도 이미 연관관계 매핑은 완료**
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
- JPQL에서 역방향으로 탐색할 일이 많음
- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향 XXXX)



### 연관관계의 주인을 정하는 기준

- 비즈니스 로직을 기준으로 연관관계의 주인을 선택 XX
- **연관관계의 주인은 외래 키의 위치를 기준으로 정해야 함**
  - 룰을 정해서, 연관관계 편의 메소드를 만들어서 1차 캐시(영속성 컨텍스트)를 잘 이용하자

## 실전 예제 - 2. 연관관계 매핑 시작

- 외래 키를 직접 가지고있는게 아니라, 참조하는 객체로~
- 설계 단계에서, 연관관계를 잘 끊어내는게 중요하다(꼭 양방향이 필요 없거든..)
- 비즈니스 로직에서 어떤게 필요한지 어떤게 필요 없는지 잘 파악
  - 예제니까,  Members에서는 Orders를 가지게 했다(실제론 X)



**단방향만 해도 모든거 다 할 수 있어!**

- 나중에 편하려고 양방향 넣는거!

다만, JPQL -> 양방향 필요하는 경우 많다 ㅎㅎ (조회할 경우가 많아서)





