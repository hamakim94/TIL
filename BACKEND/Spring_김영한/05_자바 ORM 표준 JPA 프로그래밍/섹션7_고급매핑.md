# 고급 매핑



## 상속관계 매핑

- 관계형 DB는 상속 관계 x
- 슈퍼타입 - 서브타입 관계라는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입-서브타입 관계를 매핑



DB 입장에서...(테이블) ITEM <- ALBUM, MOVIE, BOOK

- 슈퍼타입-서브타입 논리 모델을 실제 물리 모델로 구현하는 방법(3)
  - JOINED
    - 특정 컬럼으로 어떤건지 구분해서 조인해서 가져온다
    - ITEM, 다른 테이블에 PK FK
  - 단일 테이블 전략
    - 그냥 하나로 합쳐버리기(컬럼 다 때려박기)
  - 구현 클래스마다 테이블을 따로 만들어
    - 각각 중복되는 정보까지 들고 있기
    - ALBUM, MOVIE, BOOK 만 만들어



### 주요 어노테이션

- @Inheritance(strategy=InheritacneType.XXX)
  - JOINED
  - SINGLE_TABLE
    - 매우 빠름
    - 쿼리 단순, insert 단순
  - TABLE_PER_CLASS
    - 부모 클래스 타입 조회가... 안 돼..(찾을 때
    - ex) item id 5번인데 다 테이블 따로 -> 다 유니온해서 id값 찾아
- @DiscriminatorColumn(name="DTYPE")
  - 상위 엔티티 어노테이션
  - **DTYPE 생성됨**

- @DiscriminatorValue("XXX") 
  - 하위 엔티티 어노테이션


보통 상위 클래스에 해당 어노테이션을 넣는다



### 조인 전략(정석)

장점

- 정규화
- 외래 키 참조 무결성 제약조건 활용 가능
  - item만 봐도(다른 테이블에 id 알고 있을떄) 해결 가능
- 저장 공간 효율화

단점

- 조회시 조인 많이 사용, 성능 저하
- 조회 쿼리 복잡
- 데이터 저장시 INSERT SQL 2번 호출 ( 그러나 엄청 단점은 아냐)



### 단일 테이블 전략

장점

- 조인 필요 X, 조회 성능 빠름
- 조회 커리 단순

단점

- 자식 엔티티가 매핑한 값 말고는 전부 null 허용
- 단일 테이블에 모든 것을 저장 -> 테이블 커지고, 상황에 따라서 성능이 오히려 느려질수도..?
  - (보통 그 임계점을 넘진 않음)

### 구현 클래스마다 테이블 전략 -> 쓰지마

DBA, ORM 전문가 둘 다 추천 X





## @MappedSuperclass

- 공통 매핑 정보가 필요할 떄 사용(id,name)
  - id,name이 어디에서나 필요해..
  - 객체 입장에서 속성만 상속받아서 쓰고싶을 때
- 상속과 관계 없다

- 엔티티 X, 테이블과 매핑 X
- 부모 클래스를 상속 받는 **자식 클래스에 매핑 정보만 제공**
- 조회, 검색 XX(**em.find(BaseEntity) 불가**)
- 직접 생성해서 사용할 일 X -> **추상 클래스 권장**



- 테이블과 관계 X, 단순히 엔티티가 공동으로 사용하는 매핑 정보를 모으느 역할

- 주로 등록일, 수정일, 등록자, 수정자 가은 전체 엔티티에서 공통으로 적용하는 정보를 모을 떄 사용

- Cf) @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능

## 실전예제

과연, 실전에서 상속관계를 쓰냐?

- 노가다 하는게 나을 수도..
