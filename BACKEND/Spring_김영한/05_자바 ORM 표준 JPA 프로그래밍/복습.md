## 영속성 관리



요청마다 엔티티 메니저 팩토리에서 엔티티 매니저를 만들고, 필요할 떄 connection pool을 받아 DB에 접근 해 사용한다



오 스프링 컨테이너 같은 환경에선, 엔티티 매니저랑 영속성 컨텍스트가 N:1이네



### 엔티티의 생명주기

- 비영속(new, transient)
- new -> **persist** -> 영속(managed)
- 준영속(detached)
- remove : 삭제



### 엔티티 조회

em.find는 1차 캐시(영속성 컨텍스트)에서 조회하는 것

1차 캐시 -> ID(key)랑, Entity를 따로 저장

1차 캐시에 없으면 DB로 



### 영속 엔티티의 동일성 보장

- find하면 같은 거(1차 캐시), 애플리케이션 차원에서 제공



**커밋하는 시점에 INSERT 날린다! 쓰기 지연 SQL 저장소에 **

commit 하면, 먼저 flush를 한다!



### 엔티티 수정, 변경 감지(Dirty Checking)

1차 캐시 -> ID, ENtity, 스냅샷이 있어 

엔티티와 스냅샷을 비교해서 UPDATE SQL을 생성



### 플러시

- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

#### 언제?

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송(등록,수정,삭제)

#### 어떻게? -> 플러시 자동 호출

- em.flush()
- 트랜잭션 커밋
- JPQL 쿼리 실행



### 플러시 심화

- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경 내요을 DB에 동기화
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨



## 엔티티 매핑

- 기본 생성자 필수(파라미터 X public 또는 protected 생성자)



### DB 스키마 자동 생성 - 주의

#### 운영 장비에는 절대 create, create-drop, update 사용하면 안 돼



### @Enumerated

- EnumTYpe.ORDINAL 절대 사용 XXX, STRING만!



### 기본 키 매핑 방법

#### IDENTITY

- 기본 키 생성을 DB에 위임
- em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자 조회

#### SEQUENCE

- ORACLE

#### TABLE - 느림, 복잡



### 식별자 전략

- LONG형 + 대체키 + 키 생성전략



## 연관관계 매핑

외래 키 대신 객체 자체를 씀(참조)



**@ManyToOne**

**@JoinColumn(id = TABLE_ID)**



### 연관관계의 주인 => 다!

- 주인이 아닌 쪽은 읽기만 가능!
- 주인은 mappedby 속서 XX



외래 키가 있는 곳을 주인!



### 양방향 매핑 실수

- 연관관계의 주인에 값을 입력하지 않음
- 양방향 매핑시 연관관계의 주인에 값을 일벽해야함!
  - 순수한 객체 -> 양쪽
  - 무한루프 조심



## 다양한 연관관계 매핑

양방향이란 개념이 헷갈렸는데(vs 외래 키)

그냥 양 쪽에서 서로 참조하는 것, 다만 테이블 외래 키를 관리할 곳을 지정해야 함



#### **다대일 -> 가장 많이 사용**



#### 일대다 -> 일(1)이 연관관계의 주인

항상 다(N) 쪽에 외래 키가 있음

@JoinColumn 꼭 사용, 아니면 조인 테이블 방식 사용(중간에 테이블 추가)



##### **다대일 양방향으로 해결하자**





#### 일대일 : 다대일과 비슷하게



#### 다대다 : 없음

- **중간 연결 테이블을 엔티티로 승격!**



### @JoinColumn - 외래 키 매핑



## 프록시와 연관관계 관리



### 프록시

em.getReference()

프록시는 실제 객체의 참조를 보관!

프록시 객체 호출 -> 실제 객체의 메소드를 호출(wrapping)

- 타입 체크시 주의!!!!! instance of를 사용해야 함
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 -> em.getReference() 호출해도 실제 엔티티 반환!!

### 즉시 로딩과 지연 로딩

지연 로딩 LAZY -> 프록시로 조회

실제 엔티티속 멤버 객체를 사용할 때 DB 조회를 통해 초기화를 한다



### 지연 로딩만 사용해라

ManyToOne, OneToOne -> default 즉시 로딩 -> LAZY로 설정



### 영속성 전이: CASCADE

특정 엔티티 영속(persist) - 연관된 엔티티도 함께 영속

부모 저장 -> 자식도!

cascade = CascadeType.PERSIST

#### 주의점

- 연관관계 매핑과 아무 관련  X
- 그냥 편리함



### 고아 객체

- orphanRemoval = True
- 고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제

#### 주의

- **참조하는 곳이 오직 하나일 떄**
- **특정 엔티티가 개인 소유할 떄**

- OneToOne, OneToMany만 가능



#### 영속성 전이 + 고아 객체 => 생명주기

한 번에 관리~



## 값 타입

- 기본 값 타입(String 등)

### 임베디드 타입

- 복합 값 타입
- Period -> startDate, endDate
- Address -> city, street, zipcode

#### 사용법

- @Embeddable : 값 타입을 정의하는 곳에
- @Embedded : 값 타입 사용하는 곳(엔티티 멤버) 에 표시
- 기본 생성자 필수



#### 장점

- 재사용, 높은 응집도
- 해당 값 타입만 사용하는 의미 있는 메소드  만들 수 잇



### 값 타입과 불변 객체

#### 객체 타입 한계

- 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입
- 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다
- **객체의 공유 참조는 피할 수 없다**

#### 불변 객체 : 생성 시점 이후 절대 값을 변경 XX

- 객체 타입을 수정할 수 없게!
- 생성자로만 만들고 => setter XX



값 타입 쓰다가

- 식별자가 필요하고, 지속해서 값을 추적하고, 변경해야한다면 엔티티로!



## JPQL

- 나중에 queryDSL
- 근데 근본 : JPQL



객체 대상 쿼리 -> **별칭 필수**



### 프로젝션

- SELECT 저레 조회할 대상
  - 엔티티 프로젝션
  - 임베디드 타입 프로젝션
  - 스칼라 타입 프로젝션
- DISTINCT로 중복 제거

### 페이징

- 쉬움
  - setFirstResult()
  - setMaxResult()

### 경로 표현식 : 점을 찍어 객체 그래프 탐색

- **상태 필드**
  - 값 저장
- **연관 필드**
  - 단일 값 연관 필드
    - 대상이 엔티티, ManyToOne, OneToOne, 대상이 엔티티
  - 컬렉션 값 연관 필드
    - OneToMany, ManyToMany, 대상이 컬렉션



단일값 연관 경로만 조인을 통해 타색한다



### 명시적 조인만 써



## fetch join

- 성능 최적화
- SQL 한 번에 함꼐 조회
  - Member <- TEAM에서
    - 같이 ㅈ호ㅚ하기
    - select m from Member m **join fetch** m.t**eam**



### 페치 조인과 DISTINCT

- 일대 다 에서 조인 할 때, 중복 열 발생
- select distinct t
- from Team t join fetch t.members
- where t.name = '팀A'

같은 식별자를 가진 Team 엔티티 제거



**객체 그래프를 SQL 한 번에 조횜**