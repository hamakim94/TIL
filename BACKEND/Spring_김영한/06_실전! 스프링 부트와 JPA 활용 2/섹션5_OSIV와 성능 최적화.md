## OSIV와 성능 최적화

Open Session In View. 하이버네이트

Open EntityManager in Vuew : JPA

(관례상 OSIV라 한다)



스프링

- Spring.jap.open-in-view : true 기본값



트래픽 많이 일어나는 서비스면 꼭 알아야 한다



이 기본값을 뿌리면서 애플케이션 시작 시점에 warn 남김

DB 커넥션 : 1:1로 가지고 있어야함

그럼 언제 DB Connection을 가질까?

- OSIV전략은 트랜잭션 시작처럼 DB 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와 DB 커넥션을 유지
- 유저한테 response가 나와서 더이상 쓸 필요 없을 떄 까지 끝까지 살아있음
  - 지금까지 영속성 컨텍스트를 사용(lazy loading)할 수 있었던 이유
  - 장점이다



단점

- 너무 오랜시간동안 DB 커넥션 리소스를 사용, 실시간 트래픽 중요한 애플리케이션에서는 커넥션이 마른다(모자람), 결국 장애

- 만약 외부 API(3초) -> 3초동안 물고 있음..



### OSIV OFF

- 트랜잭션을 종료할 때 영속성 컨텍스트를 닫음, DB 커넥션 반환
- OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리. 많은 지연 로딩 코드를 트랜잭션 안으로 넣어야 하는 단점
- view template에서 지연로딩이 동작하지 않음. 결론적으로 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 한다.
- 끄면, repository 메서드(트랜잭션) 끝나는 순간, lazy-loading을 통해서 물려있는 객체 그래프 탐색하지 못해서(커넥션  X) 500 에러가 터짐



- 패치 조인도 좋은 해결법 중 하나! OR 트랜잭션안에 로직 담아!



단순한 경우

### 커맨드와 쿼리 분리

- 쿼리용 서비스르 만들기(따로 뺴서 트랜잭셔널 붙이기)
- 실무에서 OSIV를 끈 상태로 복잡성을 관리하는 방법!

비즈니스 로직은 okㅇ니데,

복잡한 출력하기 위한 쿼리는 화면에 맞춰 성능을 최적화하는게 중요. 그 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 아니다.

크고 복잡한 애플리케이션 -> 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 충분히 의미 있음!!!!!!!

**화면 관련 api는 라이프사이클이 짧음!!!, 즉 자주 바뀜** 

- OrderSerivce : 핵심 비즈니스 로직
- OrderQueryService : 화며이나 API에 맞춘 서비스(읽기 전용 트랜잭션)



결국, OSIV로 하다가, 나중에 리팩토링



> 강사님
>
> 고객 서비스의 실시간 API는 OSIV를 끄고, ADMIN처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 켠다.