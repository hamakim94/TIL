# 섹션4_컬렉션 조회 최적화



## V1 주문 조회: 엔티티 직접 노출

@ToOne -> 그냥 fetch join 하면 ok

하지만 @xxxToMany 0-> 중복 포인트가 많이 생겨서 문제가 생김



주문 내역에서 추가로 주문한 상품 정보를 추가로 조회하자

order -> orderItem



굳이 getName, 이런거 출력하는 이유는

프록시 내에 데이터 초기화를 위해서다





## V2 주문 조회: 엔티티를 DTO로 변환

이제 엔티티 직접 노출 X -> DTO로 변환해보자~

**DTO 만들어서 orderItems -> null이 나오네!?**

- 엔티티니까!
- 프록시 초기화 해주자

그런데, orderItems..!! 자체가 엔티티!

- 그럼 OrderItem 자체도 DTO를 만들어야..!!!!



쿼리 자체가 끔찍하게 많이 나옴

order -> member, delivery -> orderItem(2번)

order -> member, delivery -> orderItem(2번)

collection을 쓰면 최적화에 대해서 특히 고민을 많이 해야한다..



## V3 주문 조회: 엔티티 DTO - 페치 조인 최적화

join fetch 막 하면, DB 입장에서, 매우 중복되는 상황이 많이 발생하게 됨



DB의 DISTNCT는 나머지 필드까지 전부 똑같아야지 할 수 있음

그런데 JPA distinct 키워드는,

order가 같은 id값이면 중복을 제거해줌(하나 버림), 리스트 반환해서 버림



``` java
// OrderRepository
    public List<Order> findAllWithItem() {
        return em.createQuery(
                        "select distinct o from Order o " +
                                " join fetch o.member m" +
                                " join fetch o.delivery d" +
                                " join fetch o.orderItems oi" +
                                " join fetch oi.item i", Order.class)
                .getResultList();
    }
```

- sql 한 번
- application에서 추가 중복을 걸러줌(distinct), 일대다여서 발생한 문제

단점

- **페이징 불가능**
- 일대 다를 fetch join -> 페이징 쿼리가 안 나감
  - LIMIT, OFFSET 안 보여..(setFirstResult, setMaxResult)
  - 메모리에서 소팅해줄게..!!(!! 전부 메모리에서 한다고,.!?!?)

이미 조인 해놨어 -> 중복, 즉 페이징 처리가 애매해

(fetch join -> application단에서 중복. 처리를 해주기 때문에..!)

**일대다 -> 페이징 hard*=**

- 컬렉션 페치 조인 -> **페이징 불가능!**
- **컬렉션 패치 조인은 1개만 사용할 수 있따**. 컬렉션 둘 이상에 페치 조인 사용 -> 데이터 부정합하게 조회될 수 있음..



## V3.1 주문 조회 : 엔티티 DTO - 페이징과 한계 돌파



### 페이징과 한계 돌파

- 컬렉션을 패치 조인 -> 페이징 불간으
  - 일대 다 조인 -> 데이터가 예측할 수 없이 증가
  - 일대다 -> 일을 기준으로 페이징을 하는 것이 목적
  - 데이터는 다(N) 기준으로 row가 생성돼
  - Order기준 페이징 -> 다(OrderItem) 기준으로..
- 이 경우 하이버네이트는 경고 로그 -> DB 데이터 다 읽어서 메모리에서 페이징을 시도(최악의 경우 장애)



### 한계 돌파

- 페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야할까?
- 코드 단순 + 성능 최적화까지..?
  - 사실, 다른 방법 XX



1. XXXToOne -> 모두 페치 조인(row 수 증가 X)
2. 컬렉션은 지연 로딩으로 조회
3. 지연로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size.= true, @BatchSize' 이용(application.yaml 에 작성)
   - hinernate properties 아래
   - @BatchSize : 개별 최적화
   - 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size만큼 IN쿼리로 조회
4. 1, n, m 이 1, 1, 1이 되버림(쿼리의 수)



- 1번 단계 스킵하고 그냥 application에 설정만 해놓고 XXXToOne은 안 해놓으면, 기존 join 하던거 다 따로 select, select -> 네트워크 많이 탐
- 상황에 따라 V3, V3.1 어떤게 좋은지 다르다



글로벌하게 말고, 디테일하게 하면, @OneToMany 필드에 @BatchSize에 넣아야함

컬렉션이 아닌경우는, 클래스 이름에 딱 넣는다

결론은, 글로벌하게 설정하는게 편하긴 하다!!



### 정리

- 장점
  - 쿼리 호출 수 1 + N -> 1 + 1
  - 조인보다 DB 데이터 전송량이 최적화
  - 페지 조인 방식과 비교해서 쿼리 호출수는 많지만, DB 데이터 전송량이 감소
  - **컬렉션 페치 조인은 페이징 불가능, 이 방법은 페이징 가능**
- 결론
  - ToOne -> 페치 조인 OK
  - 나머지는 hibernate.default_batch_fetch_size 이용
- 배치 사이즈?
  - 100~1000 사이를 권장
  - 이 전략은 SQL IN 절 사용
  - DB마다 in 파라미터 개수 다름
    - 사실 1000이 이론상 가장 좋긴 한데
    - DB에서 애플리케이션으로 순간적으로 데이터를 확 땡김
    - DB / App 둘 다 순간적으로 부하 증가
  - 100개 설정 -> DB, APPlcation이 조금 조금 다다다다다다 한다(부하 준다. 대신 시간은 오래 걸림 ㅋ)

WAS VS DB -> 100정도 넣고 써보면서 증가~

WAS 입장에서는 10, 1000이든 결국 DB 긁어오는 개수는 똑같아서 의미 X



## V5 주문 조회 - JPA에서 DTO 직접 조회

핵심 비즈니스가 아닌, 화면에 fit한 쿼리들은, repository 안에서 패키지를 따로 만들어서 관리한다(장점이 밀접해진다~~), 핵심 비즈니스 로직은 따로 두는게 편하다(관심사 분리)



Query : 루트 1번, 컬렉션은 N번 실행

- ToOne 먼저, ToMany(1:N) : 각각 별도로 처리
  - 즉, 그냥 루프 돌면서 직접 처리했다고!!
- ㅅToMany - 별도의 루프 만들어서 조회(루프)



## V5 주문 조회 - JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화

메모리에 올려놔서 (map으로 만들어서)

샥샥!

ㅂQuery : 루트 1번, 컬렉션 1번

- ToOne 관계 -> 여기서 얻은 orderId로 ToMany 관계의 id들을 얻음
- map을 사용해서 성능 향상!



JPA DTO 직접의 유일한 장점 -> 그냥 select한 필드들이 적음!!!!!





## V6 주문조회 : JPA->DTO, 플랫 데이터 최적화(쿼리 1번)

- 한 번에 다 쪼인해서 가져와!
- 근데 페이징이 안 돼(일대다 조인 -> 중복 데이터 발생)
  - 근데 스펙이 안 맞아, OrderQueryDto로 맞추고 싶은데, flat한건 ..?
  - V5랑 같은 스펙?
  - 노가다.!(직접 중복을 거르면 돼!)

장점

- 쿼리 1번

단점

- 쿼리 한번 -> DB에서 App에 전달하는 데이터에 중복 데이터가 추가 발생 (V5보다 느릴 수 있음)
- 애플리케이션에서 추가 작업이 큼
- 페이징 불가능





## 컬렉션 조회 최적화 정리!!!



### 정리

- 엔티티 조회
  - 엔티티 조회 - 그대로 반환 : V1
  - 엔티티 조회 후 DTO 변환 -> V2
  - 페치 조인으로 쿼리 수 최적화 : V3
  - 컬렉션 페이징과 한계 돌파 : V 3.1
    - 컬렉션은 페치 조인시 페이징 불가능
    - ToOne관계는 페치 조인으로 쿼리수 최적화
    - 컬렉션은 페치 조인 대신에 지연 로딩을 유지, hibernate.default_batch_fetch_size, @BatchSize로 최적화
- DTO 직접 조회
  - JPA에서 DTO를 직접 조회: V4
  - 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN절을 활용해 메모리에 미리 조회해서 최적화: V5
  - 플랫 데이터 최적화 - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환: V6



### 권장 순서

1. 엔티티 조회 방식으로 우선 접근
   1. 페치 조인으로 쿼리 수 최적화
   2. 컬렉션 최적화
      1. 페이징 필요 -> hibernate.default_batch_fetch_size, @BatchSize
      2. 페이징 필요 X -> 페치 조인 사용
2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
3. DTO 조회 방식으로 해결 X -> NativeSQL or 스피링 JdbcTemplate



> 참고: 엔티티 조회 방식: 페치 조인, 배치 : 코드를 거의 수정하지 않고, 옵션만ㅇ 약간 변경해서 다양한 성능 최적화를 시도할 수 있음. 반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 더 많은 코드를 변경해야 함
>
> 캐싱은 DTO로! 엔티티 하지 마



> 참고: 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기, 성능 최적화 : 단순한 코드를 복잡한 코드로..!!(항상은 아님)
>
> 엔티티 조회 방식은 JPA가 많은 부분 최적화 -> 단순한 코드 유지, 성능 최적화 할 수 있음
>
> DTO 조회 방식은 SQL 직접 다루는 것과 유사하기 때문에, 둘 사이에 줄타기



### DTO 조회 방식 선택지

#### 가장 큰 차이. ( DTO VS ENTITY) : 필드 개수 최적화가 전부

- V4,V5,V6 -> 단순히 쿼리 1번이 실행된다고 항상 좋은 방법 아님
- V4는 코드가 단순, 특정 주문 한 건만 조회하면 이 방식을 사용해도 성능이 잘 나온다. 조회한 order 1건 -> orderItem 쿼리도 1번
- V5는 코드 복잡, 여러 주문을 한꺼번에 조회 -> V5가 좋긴 함
  - 조회 1000건이면, V4 : 1.+ 1000
  - V5: 1 + 1 로 바뀜(In절 활용) 운영 환경에 따라 성능 100배 이상 날 수도
- V6는 완전히 다름, 쿼리 한 번으로 최적화 , but Order를 기준으로 페이징 불가능.
  - 심지어 데이터 많으면 크게 의미 XX -> 데이터 뻥튀기



