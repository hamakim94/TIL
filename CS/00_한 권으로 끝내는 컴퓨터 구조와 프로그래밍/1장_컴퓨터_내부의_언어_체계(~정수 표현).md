# 0.들어가기 전에 
컴퓨터의 언어(단어, 문장)를 학습하기 이전에, 컴퓨터의 **문자**를 배워보자.



## 언어란 무엇인가

언어 : 정보 전달이 용이, 복잡한 개념도 설명 가능

모든 언어는 

1. 기호의 집합으로 **인코딩** (mac = 'm' + 'a'+ 'c' )
2. **문맥**이 필요함
   - 같은 단어여도 문맥에 따라 이해하는 사람이 다르기 떄문



## 문자 언어

**세 가지 구성 요소**

1. 기호가 들어갈 상자
2. 상자에 들어갈 기호
3. 상자의 순서



## 비트

자연어의 **문자** = 컴퓨터의 **비트**

비트 : binary(이진수) + digit(0~9), **비트를 사용하면 적은 비용으로 기호를 편리하게 담을 수 있다.**

비트는 이진법을 사용

- 두 기호를 이어붙여서 뜻을 만든다
- 순서, 문맥이 중요하다 ( 같은 - . - 여도 다르게 이해 가능)



컴퓨터를 사용한 계산 -> 컴퓨팅

- **비트의 의미를 부여하는 일반적인 방법**
- '척하기', -.- 이 파란색을 뜻한다고 가정 -> 실제 프로그래밍이 이렇게 작동!, 익숙해지자



## 논리 연산

비트를 활용한 의미 부여 예시 : 예(**true**) 아니오(**false**) 질문 답변

ex) 어제 저녁을 드셨나요? 

- 0 : 아니오
- 1 : 예

어디서 먹었어요? 라는 질문에는 대답을 못 한다



**논리 연산**

'날씨가 춥거나 밖에 비가 오면 코트를 입어라'를

- 추운가? 가 참이거나
- 비가 오는가? 가 참이면
  - 코트를 입는다가 참이다.

즉, 기존의 의미 부여 했던 내용을 가지고 새로운 의미로 확장시키는걸 **논리 연산**이라고 함



책 : 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 논리 연산



### 불리언 대수

비트에 사용할 수 있는 연산 규칙의 집합

**NOT**, **AND**, **OR**, XOR(두 비트가 서로 다르면 참)로 구성

cf) XOR 연산 -> (a OR b) AND (NOT (a AND b)) => **기본 불리언 연산을 조합해 똑같은 결과를!!**



### 드모르간의 법칙

a AND b = NOT( NOT a OR NOT b)

- **NOT을 사용해서 AND연산을 OR 연산으로 바꿀 수 있음**
- 원하는 대로 입력이 안 들어올 수 있어 -> **부정적인 논리, 긍정적인 논리** 바꿔가며 편한대로 입력
- NOT 연산이 무거울 수 있으니 잘 바꿔가며 연산이 가능



## 정수로 비트를 표현하는 방법

- 비트로 수를 표현 -> 논리보단 어렵지만, 문자보단 간단함

### 양의 정수 표현

10진수 -> 5132 -> 5*10^3 + 1\*10^2 + 3\*10^1 +2\*10^0 (지수를 적용할 밑을 10으로)

**숫자를 비트로 -> 2를 밑으로 하는 수 체계로!**



#### 2진수로 표현할 수 있는 값의 범위

32비트(4바이트) -> 4,294,967,296 등등..

- 가장 오른쪽의 비트 : **가장 작은 유효 비트(least siginificant bit)** - LSB
- 가장 왼쪽의 비트 : **가장 큰 유효 비트(most significant bit)** - MSB



### 2진수 덧샘

001(2) + 101(2) = 110(2) -> 가장 오른쪽인 LSB부터 MSB쪽(왼쪽)으로 더함, 결과가 1보다 크면 다음 자리(왼쪽)로

하드웨어는 어떻게?

| A    | B    | A AND B | A + B | A XOR B | A    | B    |
| ---- | ---- | ------- | ----- | ------- | ---- | ---- |
| 0    | 0    | 0       | 00    | 0       | 0    | 0    |
| 0    | 1    | 0       | 01    | 1       | 0    | 1    |
| 1    | 0    | 0       | 01    | 1       | 1    | 0    |
| 1    | 1    | 1       | 10    | 0       | 1    | 1    |

**덧샘의 결과 -> XOR**

 **올림 -> AND와 같음**

덧셈 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범이 넘어가? -> **overflow**

1111 + 0001 -> 0001 => **컴퓨터에는 조건 코드(상태 코드) 레지스터**가 있어 이상한 정보(**오버플로 비트**)를 담아둠

MSB 위쪽에서 1을 빌려오는 경우 -> **언더플로**



### 음수 표현

4비트로 음수 양수 구분 ->  부호(sign) 사용 => MSB에서 부호로 쓰자 => 오른쪽 3비트만 남음

부호비트 0 -> 양수, 1 -> 음수

**부호와 크기 표현법(sign and magnitude)**

- 단점
  - 0을 표현하는 방법 2가지
  - 부호와 크기 -> XOR와 AND를 통한 덧셈 연산 XX
- 예시
  - 0001 + 1001 (+1 + (-1) )
  - (1010) -> -2가 된다.. 0이 안 나와
  - 다른 방법 없을까?



#### |1의 보수

양수의 모든 비트를 뒤집어

0001 : 1 -> 1110 : -1 로 약속!

- 0을 두가지 방식으로 표현하는 문제
- 덧셈도 쉽지 않음
  - MSB쪽에서 올림 발생 -> LSB로 전달 -> 순환 올림(end-around carry) -> 어려움
  - 0010 + 1110 -> 0001이 되어야 함! (MSB쪽 1이 LSB쪽 1로)
- 순환 올림을 처리하기 위한 하드웨어를 추가해야 함..



#### |2의 보수

+1에 더했을 때 0이 나오는 비트 패턴을 찾고, 이를 -1로 하자

4비트, 0001 -> 1111이 -1이라고 가정!

**2의 보수** 표현법! -> 가장 널리 쓰임

비트를 뒤집고(NOT) 1을 추가하면 음수 얻을 수 있음

MSB올림 -> 버려

0을 표현하는 값이 하나! (0000 + 1111) + 1 => (0000)

**같은 숫자 -> 문맥에 따라 표현하는 값이 달라짐을 유의해야한다!**







