## 실수를 표현하는 방법

2진수를 사용해 실수 표현 -> 정수와 마찬가지로 문맥에 따라 해석 다를 수 있다



### 고정소수점 표기법

4비트 -> 2비트(정수), 2비트(분수)

| 정수 부분 |      | .    | 분수 부분 |      | 값        |
| --------- | ---- | ---- | --------- | ---- | --------- |
| 0         | 0    | .    | 0         | 0    | 0         |
| 0         | 0    | .    | 0         | 1    | 1/4       |
| 0         | 0    | .    | 1         | 0    | 1/2       |
| 0         | 0    | .    | 1         | 1    | 3/4       |
| 0         | 1    | .    | 0         | 0    | 1         |
| 0         | 1    | .    | 0         | 1    | 1 1/4 ... |
| ...       | ...  |      | ...       | ...  | ...       |

소숫점 왼쪽 -> 2진 표현법과 같음, 우측 -> 2의 거듭제곱 꼴을 분모로 활용

단점 : 쓸모 있는 범위의 실수값을 표현하기 위한 비트의 개수가 너무 많음

다만 잘 쓰이는 경우도 있음



### 부동소수점 표현법

과학적 표기법 도입(수를 해석하는 새로운 해석 방법을 도입해야 함)

10진 소수점 왼쪽이 한 자리뿐인 소수(가수), 10을 몇 번(지수) 거듭제곱 해야 하는지

0.0012 대신 1.2 * 10^-3 => 이를 이진법으로

=> 단순히 가수 부분만 보면 소수점의 위치가 변하지 않아서..!

#### 부동소수점 2진수 예시

| 가수 |      | .    | 지수 |      | 값                |
| ---- | ---- | ---- | ---- | ---- | ----------------- |
| 0    | 0    | .    | 0    | 0    | 0 * 2^0           |
| 0    | 0    | .    | 0    | 1    | 0 * 2^1           |
| 0    | 0    | .    | 1    | 0    | 0 * 2^2           |
| 0    | 0    | .    | 1    | 1    | 0 * 2^3           |
| 0    | 1    | .    | 0    | 0    | 1/2 * 2^0 = 0     |
| 0    | 1    | .    | 0    | 1    | 1/2 * 2^1 = 1.0   |
| 0    | 1    | .    | 1    | 0    | 1/2 * 2^2 = 2.0   |
| 0    | 1    | .    | 1    | 1    | 1/2 * 2^3 = 4.0   |
| 1    | 0    | .    | 0    | 0    | 1                 |
| 1    | 0    | .    | 0    | 1    | 1 * 2^1 = 2       |
| 1    | 0    | .    | 1    | 0    | 1 * 2^2 = 4       |
| 1    | 0    | .    | 1    | 1    | 1 * 2^3 = 8       |
| 1    | 1    | .    | 0    | 0    | 1 1/2 * 2^0 = 1.5 |

같은 수를 표현하는 방법이 너무 많고, 빈 공간도 많아..



### IEEE 부동소수점 수 표준

현실 : 표준, 위 4비트보다 훨씬 많이 표현, 가수와 지수부에 각각 부호 비트도 사용 => IEEE 754 규칙

트릭들이 있음

- 정규화 : 앞쪽 0 다 지워
- 디지털 이큅먼트 : 가수의 맨 왼쪽 비트가 1 -> 생략하는 것



기본 정밀도 수(단정도 실수) : 32비트 => +-10 ^ (+=38) 정도 표현 간ㅇ

2배 정밀도 수(배정도 실수) : 64비트, 



지수에 대한 부호가 없네? -> **편향된 지수값 사용**, 2진수 1 비트 패턴 -> 00000001 => -126, 11111110 -> +127

cf) 0으로나 누거나, 무한대 표현할 수 있는 특별 비트 패턴을 제공하는 편

그 중 하나가 NaN, 뭔가 잘못 했다고



## 2진 코드화한 10진수 시스템(Binary-Coded Decimal)

4비트를 사용해 10진 숫자를 하나 표현하는 방법

- 2진수로 : 1100
- BCD : 0001 0010 , 각 자리수를 4비트씩

뜬금포로 나오는 경우가 있음(디스플레이, 가속도 센서 등이 BCD 사용)



## 2진수를 다루는 쉬운 방법



### 8진 표현법

2진수 비트를 3개씩 그룹으로~(3비트가 0~7까지)

100101110001010100 -> 456124

### 16진 표현법

컴퓨터 내부가 8비트의 배수를 사용해 만들어짐

8의 배수는 4(16진 4비트)로 나눠 떨어지지만, 3으로는 안 나눠 떨어져서

11010011111111000001 => d3fc1(a,b,c,d,e,f : 10,11,12,13,14,15)



### 프로그래밍 언어의 진법 표기법

10 -> 진수를 어떤거를 보느냐에 따라 값이 다 달라짐

- 2진수 : 2
- 10진수 : 10
- 16진수 : 16

표기법

- 0으로 시작하는 숫자는 8진 숫자, 017 => 8진수
- 1부터 9 사이의 숫자로 시작하는 숫자는 10진수, 123 => 10진수
- 0x가 앞에 붙은 숫자는 16진수다. 0x12f => 16진수, 303

보통 2진수 표현을 제공하는 프로그래밍은 얼마 없음! (다만, C++은 0b 접두사 활용)



## 비트 그룹의 이름

비트 자체는 너무 작음 -> 기본 단위로 쓰기엔 부적합

| 이름        | 비트개수 |
| ----------- | -------- |
| nibble      | 4        |
| byte        | 8        |
| half word   | 16       |
| long word   | 32       |
| double word | 64       |

- 워드 : 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기
  - 컴터가 빠르게 처리할 수 있는 가장 큰 덩어리
  - ex) DEC PDP-11 : 바이트, 하프 워드, 롱 워드 처리 가능 => 내부에선 16비트로 비트 조작



큰 수 표현 체계

- 2진수로 쓰고싶고, 기존 단위(킬로 1000, 메가100만, 기가10억, 테라 1조)
- 킬로바이트 -> 2^10 (1000이랑 가까움)
- MB -> 2^20
- GB 2^30,
- T or TB : 2^40



그런데, 위 용어들이 밑이 10인 경우도 있음(디스크 크기)

미국 변호사 : 디스크 크기가  광고에 나온 것보다 작다고 디스크 제조사 고소

IEC 표준 접두사 : kibi, mebi, gibi... tebi : 2를 지수로 하는 새로운 체계



다음 : 예전에는 한 바이트 안에 문자 모두 표현하려고 했으나, 다양한 언어체계 -> 여러 바이트로!!







## 텍스트 표현

수를 사용해 문자를 어떻게 표현할까?

### 아스키 코드

정보 교환을 위한 미국 표준 코드(Amercan Standard Code for Information Exchange, ASCII)

7비트 내에 넣음

제어 문자도 있다(NUL, STX, EOT, ACK, NAK 등등)



### 다른 표준의 진화

영어 표현 가능 but 그 밖에 언어 지원

**국제 표준화 기구(ISO, International Standards Organization)** => ISO-646, ISO-8859 지원

비트 가격이 떨어짐 -> **유니코드(Unicode)** -> 문자에 16비트 코드 부여

16코비트로 될 줄 알았는데, 21비트로 확장.



### 유니코드 변환 방식 8비트

문자 코드에 따라 각기 다른 인코딩을 사용

**인코딩** : 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴

비트 - 숫자 - 문자 - 숫자 표현!

- 비트를 사용해서 숫자를 표현
- 숫자를 사용해서 문자를 표현
- 문자를 다시 숫자로 해석해서 표현!

가장 많이 쓰이는 것?

- **유니코드 변환 형식 8비트(UTF-8)** : 가장 널리 쓰이는 인코딩 방법
- 모든 아스키 문자를 8비트로
- 아스키 문자 아님 -> 아스키를 받아 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩함



#### |UTF-8 인코딩 방법

문자를 8비트 덩어리(octet)의 시퀸스로 인코딩

첫 번째 덩어리 -> 옥텟 시퀸스의 길이 표현

영어의 경우 7비트만으로 표현할 수 있기에, 매우 편함

ex) 유니코드 A -> UTF-8

- 0x0041 : 0000000001000001
  - 0100001 : UTF-8 A
  - ASCII 7비트로 표현 가능 -> MSB를 0으로, 
- 유니코드 pi : 0x03C0 : 000000111000000
  - 1101111 10000000 (0xCF 0x80)
  - 2개의 파트 덩어리
  - 첫 번째 MSB 3비트를 110으로, 두 번째 덩어리의 MSB 2 비트를 10으로
  - 첫 번째 덩어리에 5비트 남고, 두 번쨰 덩어리 6비트가 남아서 -> 11비트 코드를 모두 담을 수 있다.
- 유니코드 **☘** -> 16비트, UTF-8 덩어리를 3개 사용



## 문자를 사용한 수 표현

이전 : 문자를 숫자로 표현했다.

문자를 사용해 수를 표현하기도! -> 2진 데이터를 보내고 받을 순 없을까?

### 출력 가능(ASCII에서 제어 문자가 아닌 문자)하게 변경한 인코딩

**Quoted-Printable encoding** : QB인코딩, 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신

전자우편 첨부를 위해 만들어짐

= 다음에 각 니블을 표현하는 16진숫자 2개를 표현해 8비트값을 표현

탭과 공백 : =09, =20

인코딩된 데이터 : 한 줄이 76자 못 넘김

뒤가 =로 끝나면 가짜 줄바꿈(디코딩 시 = 제외)



### 베이스64 인코딩

1바이트 표현 -> 3바이트를 사용했던 과거의 방식은 비효율적

base64인코딩이 더 효율적 : 3바이트의 데이터를 4문자로 표현

24비트를 네 가지 6비트 덩어리로, 각 덩어리의 비트값에 출력 가능한 문자를 할당해 표현

| 숫자 | 문자 |
| ---- | ---- |
| 0    | A    |
| 1    | B    |
| 2    | C    |
| ...  | ...  |
| 63   | /    |

0, 1, 2라는 세 바이트

00000000 00000001 00000010

000000(A) 000000(A) 000100(E) 000010 (C) => AACE

원본 데이터 길이가 3바이트의 배수라는 보장 X => 패딩으로 채움



### URL 인코딩

웹 페이지 URL : %26, %2F 등의 문자 시퀸스 본 적 있?

**리터럴(literal, 특별한 의미를 지니는 문자)**

ex) '/' => 특별한 의미, 아스키 코드는 47, 16진수 2F

- 특별한 의미로 안 쓰고 싶어? 0-> /%2F라는 문자열로 대신



**문자를 사용해서, 수를 표현하는 방법들임을 명시**



## 색을 표현하는 방법

예전 : 그래프의 좌표 : 숫자 쌍을 이용

컴퓨터 

- 전자 모눈종이에 점(blob)을 찍어서 표현
- 각 격자의 찍는 점을 그림 원소(picture element), 줄여서 **pixel**



컴퓨터 모니터 : Red, Green, Blue로 색 만들어냄 ->  **RBG color model**

색은 컬러 큐브(정육면체)로 표현 가능, 각 축은 주색을 표현, 0에 가까울수록 주색이랑 멀어짐

아무 빛도 없으면 검은색, 빛을 혼합해 색을 표현하는 방식을 **가산(additive) 색 시스템**이라고 부름

- 색을 추가할수록 밝은 색이 나옴



물감 -> **감산**색 시스템, 섞을수록 어두워지기 때문

가산색 시스템(빛의 파장이 더 많은 색을 표현할 수 있음



현대 컴퓨터 -> 색을 표현하는데 24비트 활용, 1천만에 가장 가까운 2의 제곱수에 해당하는 색 표현 가능

세가지 8 비트 필드로 나뉨

24비트 단위의 전송 시스템은 없어서, long word(32비트)에 색의 정보를 담아서 처리함

나머지 8 비트 아까워 => 투명도 시스템 토입



### 투명도 추가

초기 애니메이션 -> 각 프레임을 손으로 직접, 근데 이러면 시각적인 흔들림 발생

**셀 에니메이션 개발**

움직이는 캐릭터를 투명한 셀룰로이드 필름 위에 그려, 정적인 배경 위에서 움직이게 할 수 있음

알파 색(투명도),추가 => 합성 계산법(0~1사이의 값을 합성시켜서 새로운 색을 만들기)

색이 완전 불투명 -> 알파값 1(255), 0.5 => 127, => 기존 RGB값에 곱해서 사용함



### 색 인코딩

**16진 트리플랫(hex triplet)**

#뒤에 6자리 16진 숫자 추가, #rrggbb

각각의 8비트 색값을 두자리 문자로 된 16진 표기로 바꿈.