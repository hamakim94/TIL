# 프록시와 연관관계 정리



## 프록시

### 프록시 기초

- em.find() vs em.**getReference()**
- em.find() : DB를 통해 실제 엔티티 객체 조회
- em.getReference() : **데이터베이스 조회를 미루는 가짜 프록 엔티티 객체 조회**
  - 프록시: Entity target : 진짜 객체 들어가있는거
  - 텅 빈걸 하나 가져온다Id값만 들고 있어

### 프록시 특징

- 실제 클래스를 상속받아서 만들어짐
- 실제 클래스와 겉 모양이 같다
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)
- 프록시 객체는 실재 객체의 참조(target)를 보관
- 프록시 객체를 호출 -> 프록시 객체는 실체 객체의 메소드 호출



### 프록시 객체의 초기화

getReference

1. getName()
2. MemberProxy에, target이 비었어
3. 영속성 컨텍스트에 초기화 요청
4. DB 조회 ( 실제 Entity 생성 )
5. 이제 프록시 target -> target.getName() 호출 -> 실제 객체 메서드 실행



하이버네이트가 이렇게 구현함



### &&& 프록시(Proxy)의 특징 &&&

- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할 때, **프록시 객체가 실제 엔티티로 바뀌는 것은 아님**, 촉회되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함
  - **(==비교 실패, 대신 instance of 사용)**
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.**getReference()** 해도 실제 엔티티 반환
- **영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생**
  - **하이버네이트는 LazyInitialException 예외를 터트림**
  - 미친 실무(트랜잭션이 끝나고 나서, 영속성 context 조회할 때 문제 발생)

### 프록시 확인(메서드들)

- 프록시 인스턴스의 초기화 여부 확인
  - PersistenceUnitUtil.isLoaded(Object entity)
- 프록시 클래스 확인 방법
  - entity.getClass().getName() 출력(...javasist.. or HibernateProxy...)
- 프록시 강제 초기화
  - org.hibernate.Hibernate.intialize(entity)
- 참고 : JPA 표준은 강제 초기화 XX
  - 강제 호출 : member.getName()



## 즉시 로딩과 지연 로딩

### Q) MEMBER를 조회할 때 TEAM도 조회를 해야하나..?

연관 관계가 걸려있다고 해서 필요없는 정보까지 가져와야 할까?

- 

### 지연 로딩(fetch = FetchType.LAZY)

1. 로딩(member1)
2. 지연 로딩LAZY
3. member1 속 team1 ( **프록시 team1 엔티티** )

- **실제 team을 사용하는 시점에** 초기화를 한다!!!(getClass에서는 아직 XX)



### 그러나, Member랑 Team을 함께 사용한다면?

- FetchType.EAGER ( 즉시 로딩 )
  - 조인해서 가져옴(프록시 자체가 필요 없음)

1. 로딩
2. 즉시 로딩 EAGER
3. team1 (실제 엔티티) -> SQL로 한 번에 조회해버림



### 프록시와 즉시로딩 주의

- **가급적 지연 로딩만 사용(특히 실무에서)**
- 즉시 로딩을 적용하면 에상하지 못한 SQL이 발생
- **즉시 로딩은  JPQL에서 N+1 문제를 일으킨다**
- **@ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정**
  - select m from Member m, Member.class
    - 멤버가 10명이면,  member를 찾기 위해,  member를 찾기 위한 10개의별도 명령
    - 어라, EAGER네, 그러면 각 팀을 찾기 위해 select * from Team 또 나감
- OneToMany, ManyToMany는 기본이 지연 로딩

```
Hibernate: 
    /* select
        m 
    from
        Member m */ select
            member0_.MEMBER_ID as MEMBER_I1_1_,
            member0_.createBy as createBy2_1_,
            member0_.createdDate as createdD3_1_,
            member0_.lastModifiedBy as lastModi4_1_,
            member0_.lastModifiedDate as lastModi5_1_,
            member0_.TEAM_ID as TEAM_ID7_1_,
            member0_.USERNAME as USERNAME6_1_ 
        from
            Member member0_
Hibernate: 
    select
        team0_.TEAM_ID as TEAM_ID1_2_0_,
        team0_.createBy as createBy2_2_0_,
        team0_.createdDate as createdD3_2_0_,
        team0_.lastModifiedBy as lastModi4_2_0_,
        team0_.lastModifiedDate as lastModi5_2_0_,
        team0_.name as name6_2_0_ 
    from
        Team team0_ 
    where
        team0_.TEAM_ID=?
Hibernate: 
    select
        team0_.TEAM_ID as TEAM_ID1_2_0_,
        team0_.createBy as createBy2_2_0_,
        team0_.createdDate as createdD3_2_0_,
        team0_.lastModifiedBy as lastModi4_2_0_,
        team0_.lastModifiedDate as lastModi5_2_0_,
        team0_.name as name6_2_0_ 
    from
        Team team0_ 
    where
        team0_.TEAM_ID=?
```

- 처음 쿼리를 날렸는데, 그거 떄문에 N개 쿼리를 더 써야해..!



### N+1 문제 ( 1 + N ) 문제 해결

- fetchjoin : 런타임에 동적으로 원하는 애들 결정해
- 엔티티 그래프(어노테이션)
- batch size 등등 풀 수 있다(1+1)



### 전부 LAZY로 발라라!

## 지연 로딩 활용

- Member Team 자주 함께 -> 즉시 로딩
- Member Order는 가끔 사용 -> 지연 로딩
- Order와 Product는 자주 함께 -> 즉시 로딩

다만 이론적인 부분이고, 실무에서는 다 지연 로딩 바르고 생각해~





### 실무

**전부 지연로딩**

**즉시로딩 X**

**JPQL fetch 조인, 엔티티 그래프 기능!**

**즉시 로딩은 상상하지 못한 쿼리가 나간다!**



## 영속성 전이(CASCADE)와 고아 객체

### 

### 영속성 전이: CASCADE(LAZY랑 관련 자체가 없음)

- 특정 엔티티를 영속 상태로 만들 떄 연관된 엔티티도 함께 영속상태로 만들고 싶을때
- ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장

그냥 연쇄 -> 부모 저장할 떄 연관된 애 다 !



### 주의

- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련 XX
- 엔티티를 영속화할 떄 연관된 엔티티도 함께 영속화하는 **편리함을 제공할 뿐**

### 종류

- ALL : 모두 적용
  - 라이프 사이클 다 맞출 떄
- PERSIST : 영속
- REMOVE : 삭제



### 하나의 부모가 자식들을 관리할 때만 의미 있다

ex) 게시판 -> 첨부파일

만약 하나의 파일을 여러곳이랑 같이 관리 -> 쓰지 마

부모가 하나 -> 단일 엔티티에 종속적일 때, 라이프 사이클 같을 떄 좋다!

- 막 갑자기 없어 질 수도..



## 고아 객체

- 고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
- **orphanRemoval = true**(부모가에서 설정할 수 있다 - OneToMany)
  - delete가 가 나옴



- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
- **참조하는 곳이 하나일 때 사용**
- **특정 엔티티가 개인 소유할 때 사용**
- @OneToOne, @OneToMany만 가능



- 참고 : 개념적으로 부모를 제거하면 자식은 고아가 된다, 따라서 객체 제거 기능을 활성화하면, 부모를 제거할 때 자식도 함께 제거, CascadeType.REMOVE처럼 작동



## 영속성 전이 + 고아 객체, 생명주기

**CascadeType.ALL + orphanRemoval=true**

- 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
- 두 옵션을 모두 활성화 하면 -> 부모 엔티티를 통해 자식의 생명 주기를 관리할 수 있음
- 도메운 주도 설계(DDD)의 Aggregate Root 개념을 구현할 떄 유용





## 실전 예제

- 모든 연관관계를 지연 로딩으로
- @ManyToOne, OneToOne은 기본이 즉시 로딩 -> 변경