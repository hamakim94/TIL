## 영속성 관리



요청마다 엔티티 메니저 팩토리에서 엔티티 매니저를 만들고, 필요할 떄 connection pool을 받아 DB에 접근 해 사용한다



오 스프링 컨테이너 같은 환경에선, 엔티티 매니저랑 영속성 컨텍스트가 N:1이네



### 엔티티의 생명주기

- 비영속(new, transient)
- new -> **persist** -> 영속(managed)
- 준영속(detached)
- remove : 삭제



### 엔티티 조회

em.find는 1차 캐시(영속성 컨텍스트)에서 조회하는 것

1차 캐시 -> ID(key)랑, Entity를 따로 저장

1차 캐시에 없으면 DB로 



### 영속 엔티티의 동일성 보장

- find하면 같은 거(1차 캐시), 애플리케이션 차원에서 제공



**커밋하는 시점에 INSERT 날린다! 쓰기 지연 SQL 저장소에 **

commit 하면, 먼저 flush를 한다!



### 엔티티 수정, 변경 감지(Dirty Checking)

1차 캐시 -> ID, ENtity, 스냅샷이 있어 

엔티티와 스냅샷을 비교해서 UPDATE SQL을 생성



### 플러시

- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

#### 언제?

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송(등록,수정,삭제)

#### 어떻게? -> 플러시 자동 호출

- em.flush()
- 트랜잭션 커밋
- JPQL 쿼리 실행



### 플러시 심화

- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경 내요을 DB에 동기화
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨



## 엔티티 매핑

- 기본 생성자 필수(파라미터 X public 또는 protected 생성자)



### DB 스키마 자동 생성 - 주의

#### 운영 장비에는 절대 create, create-drop, update 사용하면 안 돼



### @Enumerated

- EnumTYpe.ORDINAL 절대 사용 XXX, STRING만!



### 기본 키 매핑 방법

#### IDENTITY

- 기본 키 생성을 DB에 위임
- em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자 조회

#### SEQUENCE

- ORACLE

#### TABLE - 느림, 복잡



### 식별자 전략

- LONG형 + 대체키 + 키 생성전략



## 연관관계 매핑

외래 키 대신 객체 자체를 씀(참조)