# 22/01/25

https://www.acmicpc.net/problem/2884

- 24시간 기준으로 n분 전 : 시간, 분 나눌 떄 가장 빠르게 나눌 수 있는 기준 찾기 위해 노력
- 꼭 반대의 경우도 생각하자.

# 22/01/26

- while문에서 입력값이 없을 때
  - try-catch를 이용하면 예외상황 처리 가능

자바로 하려니 자료형 바꿔주는거 지옥이네

# 22/01/31

## 백준 15552 빠른 A+B

- br.close(), wr.close()는 마지막 한 번에, for문 안에 들어가면 계속 비워서 느려짐

## 백준 2577  숫자의 개수

-  (String.charAt(int) -'0')
  - CharAt을 하면 : String 배열에 있는 index 요소를 char형태로 되돌려준다
  - 결과 -'0' 해야 그 요소를 int로 받을 수 있다.

---

## StringTokenizer while문 사용법

~~~java
while (tokenizer.hasMoreTokens()){                     // 남은 토큰이 있다면
            tokenizer.nextToken()); // nextToken, 이거 필수다..
        }
~~~

---

## Java 데이터 타입 알아내는 법

~~~java
getClass().getSimpleName();

// ex)
String myname = "hamakim";
syso(myname.getClass().getSimpleName());
~~~

---

## Java HashMap Key 값 따라 value 변경법

~~~java
// value는 int라고 가정
hashmap.put(w, hashmap.get(w) +1);
~~~

---

## ArrayList 값 변경

~~~java
ArrayList.set(index, new_value);
~~~

## 문자열 데이터 비교

#### equals... 제기랄.. 

---

## 알파벳 활용법(char)

~~~java
// 만약 알파벳을 활용해 인덱스를 0으로 만들고 싶을 때(only 소문자)
 abc
arr[ inputString.charAt(i) - 'a'] // 0번쨰 index로 가짐
~~~

#### Int이하의 변수 타입을 사용하는 경우, 연산 시 int로 자동변환

cf) 아스키 코드

- 알파벳 개수 26개

  - 소문자 a = 97~122 
  - 대문자 A 65~90 
- 숫자 0 ~ 9 : 48 ~ 57

# 22/02/02

- DP - 일단 점화식이라고 생각하자! 그래야 빨라!
- 컴퓨터는 내 생각보다 빠름 -> 노가다 시킬 조건을 먼저 찾자

- 자존심 X, 모르면 답지 클론코딩..



# 22/02/05

## 브루트 포스 

 그냥 하나하나 다 대입해버리는거!!

## 제한조건 잘 보기

제한조건으로 갑자기 확 할 수도 있긴하네

## 반복문 돌 때

변수 미리 지정해줘(매우중요) -> 반복문 안에서 돌게하지마

그리고 string에 요소 접근할때 charAt 쓰면 엄청 편하다



# 22/02/13

## StringBuilder 활용

매번 출력하는거보다, stringbuilder에 하나씩 append하고

출력하는게 훨씬 빠르다(정렬에서, 카운팅 정렬했는데도 느려짐)



# 22/02/15

### 백만장자 프로젝트

- 각 구간별 최댓값을 찾거나 하는 문제 : 거꾸로 생각하면, 해결되는 경우가 많다.
- O(n^2) : 최대한 자제해야함.. 입력값을 보고 잘 판단해야해

# 22/04/02

### HashMap contains, Arraylis contains

- ArrayList의 contains는 indexOf를 사용하기 때문에 O(n)이고
- HashSet(map)의 contains 는 HashMap기반이고, O(1)이라고 한다

---

### Collections.sort(ans);

- 자동으로 오름차순(사전순)으로 정렬, 기본값 String정렬
- 만약 클래스에서 하려면 CompareTo나 Comparable 재정의(클래스 내부에서 )

# 22/04/04

### [], 배열 활용하기

~~~ java
List<Integer>[] list = new ArrayList[N+1];
for(int i=0; i<list.length; i++){
    list[i] = new ArrayList<>();
}
~~~

- []는 단순한 배열,  앞에 있는 건 담아놓을 자료형!
- List<>라는 인터페이스로 자료형을 설정하면, 각 배열속에 들어가 인스턴스해야함!!

# 22/04/06

### 백트래킹 잘 안 될 때

- 반대로 생각, bottom-top을 사용해..

# 22/04/07

### 재귀 (배열활용)

- 너무 어렵게 생각 하지 말기
- 한 번에 생각하지 말고, 나누고 싶은 케이스 별로 인덱스 어떻게 이동하는지, 해당 값을 어떻게 들고 다닐지만 생각. 
- 케이스가 나뉜다 -> 재귀, idx를 통해 어떻게 표현할래?

### 

### 꼭, 퍼뮤테이션 돌아야하나? 해당 단계에서 어떻게 가지가 뻗는지.

- 배열값 복사하고, 되돌릴 땐,  함부로 하면 안 됨
- 다시 되돌아가려면 새로운 배열을 만들어서 값을 복사하고 ,나중에 다시 넣어줘야함!!



# 22/04/12

### 소숫점 관련...(double)

계산을 최대한 미뤄, 그리고 가장 마지막에 소수 곱하고 결과 출력해

# 22/04/15

### 재귀 쓸 때, 중간중간 배열 저장하는 경우

- #### 얕은 복사, 깊은 복사 - 메서드 따로 만들어놔

# 22/04/26

- DP(점화식, bottom - top)
  - 초기 조건들을 활용해서 다음 조건 무 조 건 생각하기.

# 22/05/30 APS 정수

#### 1. 바르게 읽기

- 어려운 문제가 안 풀린다 -> 쉬운걸 많이 풀어봐야, 요구하는 바를 이해해야한다.

#### 2. 제대로 이해하기

- 내가 이해한 말로 바꾸기(최솟값 찾는 문제구나.. 뭐 이런느낌)

#### 3. 무엇이든 코딩하기 

- 내가 아는 걸로 최대한 해보기!!

#### 4. 손으로 눈으로 마음으로 디버깅하기

- IDE를 사용한 디버깅은 초보!
- 직접 로그를 찍기~
- 원시적일수록 고급! 불멍이라고 생각하고 그냥 하나씩 해보기~

---

### 문제내기

- 지문/그림
- 입력/출력/예제 설명
- 입력 생성 프로그램
- 샘플/평가용 데이터(10/50)
- 결과 생성 프로그램(풀이 코드)
- 문제 풀이 및 해설
  -  ㅇㅇ 1244. 최대 상금



# 22.06.03

### 내약점 

#### 1. 소수, 소수 출력

#### 2. 가지치기

#### 3. 값을 들고다니는 재귀.

# 22.06.04

## 실수

### 1. for문 안에 제한조건 : que.size()를 저장하고 조건에 넣기
- que.size()를 넣으면 길이가 poll 할 때마다 변하므로 원하는 결과가 안 나와
### 2. 굳이 ArrayList.sort(new comparater) 안 해도 돼
- 그냥 for문 2번 돌려서, 가장 작은 값 찾고, 그 중에서 최소값 구하는 공식 또 구하면 돼

---

# 22.06.23

## BFS 실수

- 시작과 끝 점이 같은 경우... 무적권 edge case에 대한 생각(2시간 out)

---

# 22.08.31

### Strings.replace( str1, str2)

~~~ java
String str = "abccccddabcdf";
System.out.println(str.replace("abc", "z")); //zcccddzdf
~~~

문자열에서 매칭되면, 바꿔주는 함수

만약 특정 문자열을 숫자로 바꿔야 한다면..

~~~ java
String[] nums = {"zero", "one", ..., "nine"} // 0부터 9까지 매칭
string input = "one3threezero";
for(int i=0; i<10; i++){
    input = input.replace(nums[i], Integer.toString(i));
}
~~~

- 중간중간 결과를 저장하기!

### String.replaceAll(String regex, String replacement)

- 정규표현식을 쓴다.
- regex 자체에 문자가 들어가도 ok야!



# 22.09.02 PGS_체육복

- 문제에서 조건이 있으면, 꼭 읽도록 하자..
- 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.
  -  단순하게 설정하면 안 되는 이유!

# 22.0903 PGS_소수만들기

### 에라토스테네스의 체 

**소수임을 판별하는 걸 따로 안 만들어도 돼!!**

- 모두가 소수라고 boolean 배열 만들어놔
- 2부터 시작해서, true면, 해당 숫자를 제외하고 그 배수 다 false로.
- 문제에서 주어진 숫자만큼 반복문 돌면 돼.



### 소수 : 1보다 큰 자연수 중 1과 자기 자신으로밖에 나눠떨어지지 않는 수

어떤 자연수![n](https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b)이 소수임을 판정하기 위해선 ![{\displaystyle {\sqrt {n}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2a2994734eae382ce30100fb17b9447fd8e99f81)까지의 수 중 1을 제외하고 그 자연수의 약수가 있는지 확인하면 된다.

- 소수가 아닌 어떤 수 N이 있다고 가정

  - N * 1 = A * B 인 수가 당연히 있다. (A,B는 자연수)

  - N의 제곱근을 M(실수)이라 해보자 

  - M\*M = A\*B

    - A>M, B< M

    - A=M, B=M

    - A<M, B>M   => 위 세가지 케이스 모두 min(A,B) <= M 을 만족한다

    - 따라서 N의 제곱근인 M까지만 나눴을 때, 나눠지면 다른 큰 하나의 약수는 알아서 매칭된다. 

    - 안 나눠지면 나눠지는 수가 없다는 뜻!


# 22.09.13 PGS 자연수뒤집어만들기

- int, long자리수 구하기

  - Integer.toString(a).length();
  - Long.toString(a).length(); 등

- 숫자를 문자로

  - String.valueOf(a)

    

## (int) (n%10)  (int) n%10 

명백히.다르다. n%10 한걸 int로 만드드냐, 아니면 n을 int로 하고 10르노 나눈 나머지를 적용하느냐



## 22.09.19 PGS 완주하지못한선수

- HashMap에서
- 중복 확인할 때, 큰거 처음 넣을 땐 1을 넣어야지.(0넣는게 아니지)
- 그 다음, 1 빼서 중복 확인 가능!!!

## 22.09.26

- split("regex", -1)
  - 음수가 들어가면 해당 구분자 기준으로 모두 나눔, 대부분 이렇게 해야해
  - 그리고 조건에서 짝수는 대문자, 홀수는 소문자 이렇게 하면
  - 짝수번째에서 이미 대문자 일 수도 있다는 거야!

## 22.09.29 String

- String.substring(idx)
  - idx번째 이후문자열 다 가져옴

- 문제 읽을때, 제대로 읽자. 첫 번째 문자만 대문자, 나머진 소문자였어.
- 'a' 97 'z' 122 'A' 65 'Z' 90 알파벳 26개

## 22.10.02 숫자의 표현

이중 for문 돌릴 떄,

어떤 조건에서 끝낼지 생각(여기선 특정 숫자들의 합이 답보다 클 땐 필요 없어!)

## 22.10.05 이진변환반복

String에서 특정 문자 제거 : replaceAll .. 또 기억하자

## 22.10.07 시저 암호(char 다루기)

- 알파벳은 26개

  - 대문자 65~90

  - 소문자 97~122       => 나머지 가지고 잘 놀아

## 22.10.09 비밀지도(문자열 다루기)

1. 비트 논리 연산자

   - 정수 (&, |, ^, ~) 정수
     - & : 두 비트 모두 1이여야 1 반환
     - | : 두 비트 중 하나가 1이면 1 반환
     - ^ : XOR : 두 비트 중 하나만 1이여야 1 반환
     - ~ : 비트 반전(보수)

2. Integer.toString(n, 2)

   - 이진수 형태로 표현돼

3. String,format( " conversion", 데이터)

   - conversion
     - %d : 10진수(정수)
     - %x : 16진수
     - %o : 8진수
     - %f : 실수
     - %s : 문자열

   - %사이 숫자 : 자리수, 만약 문자가 적으면 빈 공간으로 채워줌

     - String str = Integer.toString(input, 2);

     - String.format("%" + 자릿수 + " s", str);

   - String 보면 습관적으로 for문 돌기 보다 replaceAll을 사용하자

## 10.12 Greedy : 구명보트

- 특정한 무게(한계)가 주어졌을 때, 최솟값 구하기

-      // 최솟값 구하기
              // 무게 제한 있을 때;
              // minIdx, maxIdx를 두고,
              // 해당 합이 기준보다 작으면, answer++
              // minIdx++ maxIdx --
              // 만약 해당 합이 100보다 크면,
              // answer++
              // minIdx 그대로

- 늘 이런식으로 생각하자.

## 10.14 HashSet -> ArrayList

- set을 만들고
- ArrayList<Integer> arr = new ArrayList<>(set);
  - ArrayList sort -> Collections.sort(arr, (a,b) -> {})
  - Array sort -> Arrays.sort(arr, (a,b) -< {})

- ArrayList 자체적으로 contains 있음
- 다음엔 이클립스 써서 풀자..

​	

## 10.15 문제똑바로읽기

### 예상대진표

- 문제 입출력 예시를 보면, 다음 참가자의 번호가 어떻게 바뀌는지 알려줌
- 이게 힌트였음



## 11.25 제곱

백준 중복수열(2331)

- 제곱, Math.pow(int a,int b) 쓰기

---

## 11.27 외판원 순회

- DFS 문제로 풀 수 있고,
- 내가 현재 어디를 바라보고 있는지, 꼭 모든걸 재귀함수 내에서 처리할 필요 없다.
- 시작점을 바깥에 두고, for문을 도는 방식도 있다는걸 확인하자

---

## 11.29 스티커(DP)

- DP 문제는 N=1일떄, N=2일 떄, N=3일 때 차근차근 생각해야함
- 작은 상태에서, 최댓값 혹은 최솟값을 찾아 누적해서 더해나간다는 생각
- 기존 점수판과 똑같은 배열을 하나 만들고, 차근차근 생각해야해
- 현재 내 위치에서 어디(과거)를 비교해야 늘 최선의 수를 찾을 수 있는지 생각해야함
- 기존과 비슷한 배열을 만들어 누적해서 더해가야 한다. .. 즉 어렵다

---

## 11.30 다익스트라

- 크루스칼, 프림 => MST, 즉 최소신장트리
- 한 정점에서 다른 정점까지의 최소 비용? 다익스트라
- 모든 정점에서 모든 정점? 플로이드 와셜(경출도)

## 12.01 BFS

- 최단 거리는 BFS이다.
- 만약 BFS에서 탐욕적(최소 거리부터)으로 하고싶으면 PQ를 이용해서 내가 원하는 조건이 낮은걸로 자동적으로 정렬~

## 12.05 문자열(정규표현식)

### 문자열

- String.format("%s, %s", args) : 이렇게 넣는거 익숙해져야해
- 문자열 안에 특수문자 기준으로 split : \\\ 사용!

### 정규표현식

- . : 임의의 한 문자
- \* :없음 또는 한 개 이상
- Pattern class, matches 이용할 수 있다

~~~ java
Pattern pattern = Pattern.compile("regex");
boolean ans = pattern.matcher("문자열".matches());
~~~

## 12.14 반복문

- 인덱스 습관적으로 N으로 생각하지 말기
- 각 인덱스마다 i 쓰지 말고 의미 생각하자 이제!

## 12.16 소숫점

1. printf 사용
   - System.out.printf("%.6f\n", n\*n*Math.PI);
2. String.format사용
   1. System.out.println(String.format("%.6f", n\*n*Math.PI));

- 출력(format)
  - %d : 정수
  - %s : 문자열
  - %c : 문자
  - %f : 실수, 부동 소숫점 형식으로 출력 %.(원하는 자릿수)f
  - 기타 등등!



# 2023!

## 23.06.18 

### int vs long

자료의 수가 1,000,000, 정도고, 조합이 nC2를 하면, 정수의 범위가 넘어가는걸 눈치채자

### 나머지 + 구간합

(A+B) % C = ( (A % C) + (B % C) )  % C

각 구간합을 M으로 나눠서 구간합 배열을 저장하고

같은 수가 나온 값을 뺴면 나머지가 0이라는 뜻!!!!!



### 투 포인터

**연속된** 자연수의 합 구하기 : 시작, 끝을 관리하는 숫자(인덱스, 포인터) 만들기

내 생각 : 일단 오른쪽으로 늘리다가, 합이 더 커지면 왼쪽 한 칸 뺴!

#### 규칙

- sum > N : sum-start; start++;
- sum < N :  end++, sum + end;
- sum == N : end++, sum += end; count++;

-  edgecase 관리 ( )

## 23.06.19

- 투 포인터(주몽)
  - 한 쪽은 증가, 한 쪽은 감소라는 명확한 기준이 필요!
  - 합이 아니니까,
  - sort 하고,
    - 인덱스 증가, 감소 시키면서 원하는 값을 구하는게 답이다.
    - 문제 똑바로 읽기..!

**투 포인터의 방향은 우리가 원하는 대로 구현하는 것!**

- 기준을 따라 3개의 if문으로 원하는 것을  greedy하게 찾는다!



### 좋다

- 정렬 -> 투포인터 -> N^2보다 더 빠르게, 2개를 뽑거나 구간 합을 구하는 경우 사용
- l < r 인 조건 자체가, 이미 같은걸 2번 뽑을 수 없음
- **그리고 최대한 전체에서 찾아야지, 내가 가진 범위에서 찾으려고 하면 error**
- 근데 같은 수가 여러 개 있을 수 있으므로,
  - 해당 조건 내에서 예외처리가 되도록
  - 만약 i == k(현재 idx라면), i++
  - j == k라면, j--
    - 이런 식으로 범위를 좁혀나가면, 결국 큰 while(l < r) 에 걸려서 나오게 된다는걸. 매번 명심하고 해당 조건을 활용해서 범위를 좁혀나가자(전체에서~)
  - 심지어 양수, 음수라 어떻게 더해질지 모르니까 전체 범위로 하는게 맞다.!





## 23.06.28

- 백준 MBTI 문제(가장가까운거리)
  - 조합
    - 방문처리 필수(내가 방문 했던 곳이면 가지 마)
    - 백트래킹을 쓰면, 인덱스 시작 지점을 파라미터로 넣어야 한다. 재귀랑 조금 다르다!!
  - 순열, 조합 다시 공부해야 할듯.
  - **또한, 비둘기집의 원리를 통해서, EDGE-CASE 대피할 수도 있음!!!**
    - **총 MBTI 16개, -> 32개 이상이면, 같은 거 꼭 3개는 나옴!!**



## 23.07.05

분할정복(색종이)

재귀

- 무적권 손으로 그리기.
- 재귀 활용 인덱스 -> 풀어본 문제일수록 손으로 풀어야 빠르고 정확



## 23.07.08

토스 시험을 봤다

어려웠답!

아직 지문이 길면 겁을 먹는다. 화이팅



## 23.08.04

- br.readLine() ( L 대문자)

``` java
PriorityQueue<Integer>[] pq = new PriorityQueue[size];
for(int i=0; i<size; i++){
  pq[i] = new PriorityQueue<Integer>((a,b) -> b - a);
}
```
